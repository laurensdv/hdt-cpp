<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::memory::vyukov_queue_pool&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html">vyukov_queue_pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::memory::vyukov_queue_pool&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__memory__pool.html">Simple memory pool</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Free-list based on bounded lock-free queue <a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::intrusive::VyukovMPMCCycleQueue</a>.  
 <a href="classcds_1_1memory_1_1vyukov__queue__pool.html#details">More...</a></p>

<p><code>#include &lt;cds/memory/vyukov_queue_pool.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a859308d601430789036188f51e75cad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859308d601430789036188f51e75cad7"></a>
typedef <br class="typebreak" />
<a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html">cds::intrusive::VyukovMPMCCycleQueue</a><br class="typebreak" />
&lt; T, Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#a859308d601430789036188f51e75cad7">queue_type</a></td></tr>
<tr class="memdesc:a859308d601430789036188f51e75cad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue type. <br /></td></tr>
<tr class="separator:a859308d601430789036188f51e75cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0c4af604d77e19ea604cc445051148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb0c4af604d77e19ea604cc445051148"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a></td></tr>
<tr class="memdesc:aeb0c4af604d77e19ea604cc445051148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br /></td></tr>
<tr class="separator:aeb0c4af604d77e19ea604cc445051148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c419dd372e7997eae8dd58dcd7305a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49c419dd372e7997eae8dd58dcd7305a"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#a49c419dd372e7997eae8dd58dcd7305a">traits</a></td></tr>
<tr class="memdesc:a49c419dd372e7997eae8dd58dcd7305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type. <br /></td></tr>
<tr class="separator:a49c419dd372e7997eae8dd58dcd7305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cd5507c906cda0fda7f2538d496e28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4cd5507c906cda0fda7f2538d496e28"></a>
typedef <br class="typebreak" />
traits::allocator::template <br class="typebreak" />
rebind&lt; <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#ab4cd5507c906cda0fda7f2538d496e28">allocator_type</a></td></tr>
<tr class="memdesc:ab4cd5507c906cda0fda7f2538d496e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br /></td></tr>
<tr class="separator:ab4cd5507c906cda0fda7f2538d496e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f2d52eee891c7325a560fd3788e244e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#a9f2d52eee891c7325a560fd3788e244e">vyukov_queue_pool</a> (size_t nCapacity=0)</td></tr>
<tr class="memdesc:a9f2d52eee891c7325a560fd3788e244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocates the pool of object.  <a href="#a9f2d52eee891c7325a560fd3788e244e">More...</a><br /></td></tr>
<tr class="separator:a9f2d52eee891c7325a560fd3788e244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bc07a2792bf429bbd42d304b5e9f6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0bc07a2792bf429bbd42d304b5e9f6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#ae0bc07a2792bf429bbd42d304b5e9f6b">~vyukov_queue_pool</a> ()</td></tr>
<tr class="memdesc:ae0bc07a2792bf429bbd42d304b5e9f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the pool. <br /></td></tr>
<tr class="separator:ae0bc07a2792bf429bbd42d304b5e9f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639e3213eb0412b75d1df34a6ba38350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#a639e3213eb0412b75d1df34a6ba38350">allocate</a> (size_t n)</td></tr>
<tr class="memdesc:a639e3213eb0412b75d1df34a6ba38350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object from pool.  <a href="#a639e3213eb0412b75d1df34a6ba38350">More...</a><br /></td></tr>
<tr class="separator:a639e3213eb0412b75d1df34a6ba38350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d066048b0cee42a2536d38c9fb8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aa11d066048b0cee42a2536d38c9fb8c5">deallocate</a> (<a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a> *p, size_t n)</td></tr>
<tr class="memdesc:aa11d066048b0cee42a2536d38c9fb8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocated the object <code>p</code>.  <a href="#aa11d066048b0cee42a2536d38c9fb8c5">More...</a><br /></td></tr>
<tr class="separator:aa11d066048b0cee42a2536d38c9fb8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = vyukov_queue_pool_traits&gt;<br />
class cds::memory::vyukov_queue_pool&lt; T, Traits &gt;</h3>

<p>Free-list based on bounded lock-free queue <a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::intrusive::VyukovMPMCCycleQueue</a>. </p>
<p>Template parameters:</p><ul>
<li><code>T</code> - the type of object maintaining by free-list</li>
<li><code>Traits</code> - traits for <a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::intrusive::VyukovMPMCCycleQueue</a> class plus <a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">cds::opt::allocator</a> option, defaul is <code><a class="el" href="structcds_1_1memory_1_1vyukov__queue__pool__traits.html" title="vyukov_queue_pool traits ">vyukov_queue_pool_traits</a></code> </li>
</ul>
<p><b>Internals</b> </p>
<p>This free-list is very simple. At construction time, the free-list allocates the array of N items and stores them into queue, where N is the queue capacity. When allocating the free-list tries to pop an object from internal queue i.e. from preallocated pool. If success the popped object is returned. Otherwise a new one is allocated. When deallocating, the free-list checks whether the object is from preallocated pool. If so, the object is pushed into queue, otherwise it is deallocated by using the allocator provided. The pool can manage more than <code>N</code> items but only <code>N</code> items is contained in the free-list.</p>
<p><b>Usage</b> </p>
<p><code>vyukov_queue_pool</code> should be used together with <a class="el" href="classcds_1_1memory_1_1pool__allocator.html">pool_allocator</a>. You should declare an static object of type <code>vyukov_queue_pool</code>, provide an accessor to that object and use <code><a class="el" href="classcds_1_1memory_1_1pool__allocator.html" title="Pool allocator adapter. ">pool_allocator</a></code> as an allocator: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/memory/vyukov_queue_pool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/memory/pool_allocator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Pool of Foo object of size 1024.</span></div>
<div class="line"><span class="keyword">struct </span>pool_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1memory_1_1vyukov__queue__pool__traits.html">cds::memory::vyukov_queue_pool_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1opt_1_1v_1_1static__buffer.html">cds::opt::v::static_buffer&lt; Foo, 1024 &gt;</a> buffer;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1memory_1_1vyukov__queue__pool.html">cds::memory::vyukov_queue_pool&lt; Foo, pool_traits &gt;</a> pool_type;</div>
<div class="line"><span class="keyword">static</span> pool_type thePool;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>pool_accessor {</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> pool_type::value_type  <a class="code" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a>;</div>
<div class="line"></div>
<div class="line">    pool_type&amp; operator()()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> thePool;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare pool allocator</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1memory_1_1pool__allocator.html">cds::memory::pool_allocator&lt; Foo, pool_accessor &gt;</a>   pool_allocator;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Use pool_allocator</span></div>
<div class="line"><span class="comment">// Allocate an object</span></div>
<div class="line">Foo * p = pool_allocator().allocate( 1 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// construct object</span></div>
<div class="line"><span class="keyword">new</span>(p) Foo;</div>
<div class="line"></div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Destruct object</span></div>
<div class="line">p-&gt;~Foo();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Deallocate object</span></div>
<div class="line">pool_allocator().deallocate( p , 1 );</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f2d52eee891c7325a560fd3788e244e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = vyukov_queue_pool_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html">cds::memory::vyukov_queue_pool</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html">vyukov_queue_pool</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preallocates the pool of object. </p>
<p><code>nCapacity</code> argument is the queue capacity. It should be passed if the queue is based on dynamically-allocated buffer. See <a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::intrusive::VyukovMPMCCycleQueue</a> for explanation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a639e3213eb0412b75d1df34a6ba38350"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = vyukov_queue_pool_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a>* <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html">cds::memory::vyukov_queue_pool</a>&lt; T, Traits &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object from pool. </p>
<p>The pool supports allocation only single object (<code>n</code> = 1). If <code>n</code> &gt; 1 the behaviour is undefined.</p>
<p>If the queue is not empty, the popped value is returned. Otherwise, a new value allocated. </p>

</div>
</div>
<a class="anchor" id="aa11d066048b0cee42a2536d38c9fb8c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = vyukov_queue_pool_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html">cds::memory::vyukov_queue_pool</a>&lt; T, Traits &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html#aeb0c4af604d77e19ea604cc445051148">value_type</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocated the object <code>p</code>. </p>
<p>The pool supports allocation only single object (<code>n</code> = 1). If <code>n</code> &gt; 1 the behaviour is undefined.</p>
<p>If <code>p</code> is from preallocated pool, it pushes into the queue. Otherwise, <code>p</code> is deallocated by allocator provided. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/memory/vyukov_queue_pool.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:27 by Doxygen 1.8.8</i>
</div>
</body>
</html>
