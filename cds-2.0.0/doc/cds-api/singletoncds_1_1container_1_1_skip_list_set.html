<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::container::SkipListSet&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">SkipListSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SkipListSet&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list set.  
 <a href="singletoncds_1_1container_1_1_skip_list_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/impl/skip_list_set.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SkipListSet&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="singletoncds_1_1container_1_1_skip_list_set.png" usemap="#cds::container::SkipListSet&lt; GC, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::SkipListSet&lt; GC, T, Traits &gt;_map" name="cds::container::SkipListSet&lt; GC, T, Traits &gt;_map">
<area href="singletoncds_1_1intrusive_1_1_skip_list_set.html" title="Lock-free skip-list set. " alt="cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;" shape="rect" coords="0,0,256,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e7618174987a3d3e4b02cc22398eb3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e7618174987a3d3e4b02cc22398eb3c"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a0e7618174987a3d3e4b02cc22398eb3c">gc</a></td></tr>
<tr class="memdesc:a0e7618174987a3d3e4b02cc22398eb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br /></td></tr>
<tr class="separator:a0e7618174987a3d3e4b02cc22398eb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bae06c446486a883e3bf8cd9c65950d"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a></td></tr>
<tr class="separator:a9bae06c446486a883e3bf8cd9c65950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721b844394ec66e96a63398c0163c39b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a721b844394ec66e96a63398c0163c39b"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a721b844394ec66e96a63398c0163c39b">traits</a></td></tr>
<tr class="memdesc:a721b844394ec66e96a63398c0163c39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options specified. <br /></td></tr>
<tr class="separator:a721b844394ec66e96a63398c0163c39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f26d3fa2a526f4bd41faafc70ea69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648f26d3fa2a526f4bd41faafc70ea69"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a648f26d3fa2a526f4bd41faafc70ea69">back_off</a></td></tr>
<tr class="memdesc:a648f26d3fa2a526f4bd41faafc70ea69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a648f26d3fa2a526f4bd41faafc70ea69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94846872723dcfc3173be186e71e7d71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94846872723dcfc3173be186e71e7d71"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a94846872723dcfc3173be186e71e7d71">allocator_type</a></td></tr>
<tr class="memdesc:a94846872723dcfc3173be186e71e7d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the skip-list nodes. <br /></td></tr>
<tr class="separator:a94846872723dcfc3173be186e71e7d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e0a522b53a52e02b3f3490b91567f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e0a522b53a52e02b3f3490b91567f8"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a60e0a522b53a52e02b3f3490b91567f8">item_counter</a></td></tr>
<tr class="memdesc:a60e0a522b53a52e02b3f3490b91567f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a60e0a522b53a52e02b3f3490b91567f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4f0530a3e75b25503aa1764b85cec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bd4f0530a3e75b25503aa1764b85cec"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a8bd4f0530a3e75b25503aa1764b85cec">key_comparator</a></td></tr>
<tr class="memdesc:a8bd4f0530a3e75b25503aa1764b85cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a8bd4f0530a3e75b25503aa1764b85cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb13db4d40eefa97680c6b2776c586cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb13db4d40eefa97680c6b2776c586cb"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#adb13db4d40eefa97680c6b2776c586cb">memory_model</a></td></tr>
<tr class="memdesc:adb13db4d40eefa97680c6b2776c586cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:adb13db4d40eefa97680c6b2776c586cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e75c39713dd6a1d8d13e5bfcc6c983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50e75c39713dd6a1d8d13e5bfcc6c983"></a>
typedef <br class="typebreak" />
traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a50e75c39713dd6a1d8d13e5bfcc6c983">random_level_generator</a></td></tr>
<tr class="memdesc:a50e75c39713dd6a1d8d13e5bfcc6c983"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a50e75c39713dd6a1d8d13e5bfcc6c983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added324c1bdcb8ee938ac50410508d7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="added324c1bdcb8ee938ac50410508d7e"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#added324c1bdcb8ee938ac50410508d7e">stat</a></td></tr>
<tr class="memdesc:added324c1bdcb8ee938ac50410508d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:added324c1bdcb8ee938ac50410508d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c912a4c58cfa22165e7d7807d79b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c912a4c58cfa22165e7d7807d79b2d"></a>
typedef gc::template <br class="typebreak" />
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <br class="typebreak" />
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>, <br class="typebreak" />
details::guarded_ptr_cast_set<br class="typebreak" />
&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a></td></tr>
<tr class="memdesc:a96c912a4c58cfa22165e7d7807d79b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a96c912a4c58cfa22165e7d7807d79b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb219352dd6491a5efac6dd0b924a5fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb219352dd6491a5efac6dd0b924a5fd"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; typename <br class="typebreak" />
base_class::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a></td></tr>
<tr class="memdesc:abb219352dd6491a5efac6dd0b924a5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br /></td></tr>
<tr class="separator:abb219352dd6491a5efac6dd0b924a5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd31d37191b0182f57e887790753e3bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd31d37191b0182f57e887790753e3bb"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; typename <br class="typebreak" />
base_class::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a></td></tr>
<tr class="memdesc:acd31d37191b0182f57e887790753e3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:acd31d37191b0182f57e887790753e3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7835f9284e72b8e4b6b2e7825cfeef8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#ab7835f9284e72b8e4b6b2e7825cfeef8">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. <br /></td></tr>
<tr class="separator:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cec296de8b05a21cd626f8c0811def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cec296de8b05a21cd626f8c0811def"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a41cec296de8b05a21cd626f8c0811def">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:a41cec296de8b05a21cd626f8c0811def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys the set object. <br /></td></tr>
<tr class="separator:a41cec296de8b05a21cd626f8c0811def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dd0abb2d62d736d13083778e5ca3fe6"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a3dd0abb2d62d736d13083778e5ca3fe6">begin</a> ()</td></tr>
<tr class="memdesc:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f7bb4aa7bf1087f0d0f8ee81714685"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#ac2f7bb4aa7bf1087f0d0f8ee81714685">begin</a> () const </td></tr>
<tr class="memdesc:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482c1fdd88933e33c73498d01019d18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0482c1fdd88933e33c73498d01019d18"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a0482c1fdd88933e33c73498d01019d18">cbegin</a> () const </td></tr>
<tr class="memdesc:a0482c1fdd88933e33c73498d01019d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a0482c1fdd88933e33c73498d01019d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35161588bd79205c81b84919c7722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a35161588bd79205c81b84919c7722c"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a2a35161588bd79205c81b84919c7722c">end</a> ()</td></tr>
<tr class="memdesc:a2a35161588bd79205c81b84919c7722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a2a35161588bd79205c81b84919c7722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68b139c37edcc6da3bb52bbd289fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd68b139c37edcc6da3bb52bbd289fdb"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#afd68b139c37edcc6da3bb52bbd289fdb">end</a> () const </td></tr>
<tr class="memdesc:afd68b139c37edcc6da3bb52bbd289fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:afd68b139c37edcc6da3bb52bbd289fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b01b76929db72627903bd20addccb9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b01b76929db72627903bd20addccb9e"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a7b01b76929db72627903bd20addccb9e">cend</a> () const </td></tr>
<tr class="memdesc:a7b01b76929db72627903bd20addccb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a7b01b76929db72627903bd20addccb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e9f24060a29d05a775108a323b804b"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a58e9f24060a29d05a775108a323b804b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a58e9f24060a29d05a775108a323b804b">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a58e9f24060a29d05a775108a323b804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a58e9f24060a29d05a775108a323b804b">More...</a><br /></td></tr>
<tr class="separator:a58e9f24060a29d05a775108a323b804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a4f437617d9f9b09b0fc6358b3471bbe3">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4f437617d9f9b09b0fc6358b3471bbe3">More...</a><br /></td></tr>
<tr class="separator:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28831477fa76661cfeb2fe4884ef025c"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a28831477fa76661cfeb2fe4884ef025c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a28831477fa76661cfeb2fe4884ef025c">ensure</a> (const Q &amp;val, Func func)</td></tr>
<tr class="memdesc:a28831477fa76661cfeb2fe4884ef025c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the item exists in the set.  <a href="#a28831477fa76661cfeb2fe4884ef025c">More...</a><br /></td></tr>
<tr class="separator:a28831477fa76661cfeb2fe4884ef025c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#adb97ed3e2b3a677fb0a9abbf9025477e">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#adb97ed3e2b3a677fb0a9abbf9025477e">More...</a><br /></td></tr>
<tr class="separator:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9c4e9e93f23fe55fc1a13c0998dc2267">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a9c4e9e93f23fe55fc1a13c0998dc2267">More...</a><br /></td></tr>
<tr class="separator:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a52388afd06ea35ed1cbd785dba52ac0f">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a52388afd06ea35ed1cbd785dba52ac0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a52388afd06ea35ed1cbd785dba52ac0f">More...</a><br /></td></tr>
<tr class="separator:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#aa2542991a0a9f2348c9b6c5cca0ae1a1">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#aa2542991a0a9f2348c9b6c5cca0ae1a1">More...</a><br /></td></tr>
<tr class="separator:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bf176ad8950298a770a801f5bd68bb"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae6bf176ad8950298a770a801f5bd68bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#ae6bf176ad8950298a770a801f5bd68bb">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ae6bf176ad8950298a770a801f5bd68bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ae6bf176ad8950298a770a801f5bd68bb">More...</a><br /></td></tr>
<tr class="separator:ae6bf176ad8950298a770a801f5bd68bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2284cfd210c096378fe7c86157290c"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aab2284cfd210c096378fe7c86157290c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#aab2284cfd210c096378fe7c86157290c">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aab2284cfd210c096378fe7c86157290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with specified <code>key</code>.  <a href="#aab2284cfd210c096378fe7c86157290c">More...</a><br /></td></tr>
<tr class="separator:aab2284cfd210c096378fe7c86157290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb845ff13864d403412b08dd897599d5"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:acb845ff13864d403412b08dd897599d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acb845ff13864d403412b08dd897599d5">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:acb845ff13864d403412b08dd897599d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with comparing functor <code>pred</code>.  <a href="#acb845ff13864d403412b08dd897599d5">More...</a><br /></td></tr>
<tr class="separator:acb845ff13864d403412b08dd897599d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95f728e6e8f7f78a29a16912a890bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#ad95f728e6e8f7f78a29a16912a890bb8">extract_min</a> ()</td></tr>
<tr class="memdesc:ad95f728e6e8f7f78a29a16912a890bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the set.  <a href="#ad95f728e6e8f7f78a29a16912a890bb8">More...</a><br /></td></tr>
<tr class="separator:ad95f728e6e8f7f78a29a16912a890bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d471ab598f474a25ff8fb8930960f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a5d471ab598f474a25ff8fb8930960f66">extract_max</a> ()</td></tr>
<tr class="memdesc:a5d471ab598f474a25ff8fb8930960f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the set.  <a href="#a5d471ab598f474a25ff8fb8930960f66">More...</a><br /></td></tr>
<tr class="separator:a5d471ab598f474a25ff8fb8930960f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7464492eb3755390cb4bda3c82f8b30"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ab7464492eb3755390cb4bda3c82f8b30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#ab7464492eb3755390cb4bda3c82f8b30">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:ab7464492eb3755390cb4bda3c82f8b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the <code>key</code>.  <a href="#ab7464492eb3755390cb4bda3c82f8b30">More...</a><br /></td></tr>
<tr class="separator:ab7464492eb3755390cb4bda3c82f8b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808f79ca28e33da97182166d4f0b1110"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a808f79ca28e33da97182166d4f0b1110"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a808f79ca28e33da97182166d4f0b1110">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a808f79ca28e33da97182166d4f0b1110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a808f79ca28e33da97182166d4f0b1110">More...</a><br /></td></tr>
<tr class="separator:a808f79ca28e33da97182166d4f0b1110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eaad8e589246d4e7c83814a6066826"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a98eaad8e589246d4e7c83814a6066826"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a98eaad8e589246d4e7c83814a6066826">find</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a98eaad8e589246d4e7c83814a6066826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <code>key</code>.  <a href="#a98eaad8e589246d4e7c83814a6066826">More...</a><br /></td></tr>
<tr class="separator:a98eaad8e589246d4e7c83814a6066826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1675214d411e8d7d7a6d51ea536b00"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a5f1675214d411e8d7d7a6d51ea536b00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a5f1675214d411e8d7d7a6d51ea536b00">find_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5f1675214d411e8d7d7a6d51ea536b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a5f1675214d411e8d7d7a6d51ea536b00">More...</a><br /></td></tr>
<tr class="separator:a5f1675214d411e8d7d7a6d51ea536b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1806975cd89b92067fdce2a1665447"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9d1806975cd89b92067fdce2a1665447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9d1806975cd89b92067fdce2a1665447">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9d1806975cd89b92067fdce2a1665447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a9d1806975cd89b92067fdce2a1665447">More...</a><br /></td></tr>
<tr class="separator:a9d1806975cd89b92067fdce2a1665447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128d744ba364f91fdd733284659d2565"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a128d744ba364f91fdd733284659d2565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a128d744ba364f91fdd733284659d2565">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a128d744ba364f91fdd733284659d2565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a128d744ba364f91fdd733284659d2565">More...</a><br /></td></tr>
<tr class="separator:a128d744ba364f91fdd733284659d2565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3b2f71972becaa6a28de52ef3956bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a2f3b2f71972becaa6a28de52ef3956bc">clear</a> ()</td></tr>
<tr class="memdesc:a2f3b2f71972becaa6a28de52ef3956bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic).  <a href="#a2f3b2f71972becaa6a28de52ef3956bc">More...</a><br /></td></tr>
<tr class="separator:a2f3b2f71972becaa6a28de52ef3956bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6994d9dcb9b7fb2b339833107efceaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6994d9dcb9b7fb2b339833107efceaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#af6994d9dcb9b7fb2b339833107efceaf">empty</a> () const </td></tr>
<tr class="memdesc:af6994d9dcb9b7fb2b339833107efceaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br /></td></tr>
<tr class="separator:af6994d9dcb9b7fb2b339833107efceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfdb785d05781a79097c8d289392ae6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a3cfdb785d05781a79097c8d289392ae6">size</a> () const </td></tr>
<tr class="memdesc:a3cfdb785d05781a79097c8d289392ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a3cfdb785d05781a79097c8d289392ae6">More...</a><br /></td></tr>
<tr class="separator:a3cfdb785d05781a79097c8d289392ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f1bca5f4a30ebe761f6ded4234451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170f1bca5f4a30ebe761f6ded4234451"></a>
<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#added324c1bdcb8ee938ac50410508d7e">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a170f1bca5f4a30ebe761f6ded4234451">statistics</a> () const </td></tr>
<tr class="memdesc:a170f1bca5f4a30ebe761f6ded4234451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a170f1bca5f4a30ebe761f6ded4234451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_singletoncds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab687ac3a8e557334e59f7b0373b70f0d"></a>
typedef <br class="typebreak" />
node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ab687ac3a8e557334e59f7b0373b70f0d">atomic_node_ptr</a></td></tr>
<tr class="memdesc:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked node pointer. <br /></td></tr>
<tr class="separator:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c805bcce3eb95b1fc81ed212a90b3c5"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a8c805bcce3eb95b1fc81ed212a90b3c5">marked_node_ptr</a></td></tr>
<tr class="memdesc:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br /></td></tr>
<tr class="separator:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121ea0b7fdd8c0e6796409fce834305e"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a></td></tr>
<tr class="memdesc:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e97287193c265e405565645f3f3809 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e97287193c265e405565645f3f3809"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a></td></tr>
<tr class="memdesc:a56e97287193c265e405565645f3f3809 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br /></td></tr>
<tr class="separator:a56e97287193c265e405565645f3f3809 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd2004e9bb6cf6a6df8cf39f9b00c27"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a0dd2004e9bb6cf6a6df8cf39f9b00c27">traits</a></td></tr>
<tr class="memdesc:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9abd070c6551d3fc3c46f0f70126c5"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a></td></tr>
<tr class="memdesc:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c111410605d85dee2daf622820e34 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1c111410605d85dee2daf622820e34"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a></td></tr>
<tr class="memdesc:aeb1c111410605d85dee2daf622820e34 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:aeb1c111410605d85dee2daf622820e34 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4549fb15869b93cf05194c65fed873"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a3f4549fb15869b93cf05194c65fed873">key_comparator</a></td></tr>
<tr class="memdesc:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br /></td></tr>
<tr class="separator:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9b394b2f922a1400b2eb2c3e6b2bacc"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae9b394b2f922a1400b2eb2c3e6b2bacc">disposer</a></td></tr>
<tr class="memdesc:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item disposer <br /></td></tr>
<tr class="separator:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada7c65a30daf01ebe2e7c365f01d1129"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak" />
&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a> &gt;<br class="typebreak" />
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a></td></tr>
<tr class="memdesc:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ba2cd482243590355f3e07f31d5410"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ad5ba2cd482243590355f3e07f31d5410">item_counter</a></td></tr>
<tr class="memdesc:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8d335de0dc676276ffb41c842da0f0e"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ac8d335de0dc676276ffb41c842da0f0e">memory_model</a></td></tr>
<tr class="memdesc:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af8cf6e792b254e40124b677f946913 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af8cf6e792b254e40124b677f946913"></a>
typedef <br class="typebreak" />
traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a1af8cf6e792b254e40124b677f946913">random_level_generator</a></td></tr>
<tr class="memdesc:a1af8cf6e792b254e40124b677f946913 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a1af8cf6e792b254e40124b677f946913 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574d4a097c85e8f016b02775084d8188 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a574d4a097c85e8f016b02775084d8188"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a574d4a097c85e8f016b02775084d8188">allocator_type</a></td></tr>
<tr class="memdesc:a574d4a097c85e8f016b02775084d8188 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br /></td></tr>
<tr class="separator:a574d4a097c85e8f016b02775084d8188 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d807ce1c14954306ea2e1c51cb302b7"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a></td></tr>
<tr class="memdesc:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a61dadcef3d9667a679d57f7443a42"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a></td></tr>
<tr class="memdesc:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a758da15b68e18ac7bd73c0f4aeae67f8"></a>
typedef gc::template <br class="typebreak" />
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a></td></tr>
<tr class="memdesc:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5837aaa0b5d7e47b3df0b13c66ed4f"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, <br class="typebreak" />
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a></td></tr>
<tr class="memdesc:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br /></td></tr>
<tr class="separator:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf8dabaa6f1f1bacee706f8c71e0896"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, <br class="typebreak" />
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a></td></tr>
<tr class="memdesc:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae919ad1a045a397fda269e2c2924b818">More...</a><br /></td></tr>
<tr class="separator:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71bc587ae2e26e0fb5aae6fbc155e3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aa71bc587ae2e26e0fb5aae6fbc155e3f">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br /></td></tr>
<tr class="separator:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b00185809fb7842667287ed4a2ee0c2"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a4b00185809fb7842667287ed4a2ee0c2">begin</a> ()</td></tr>
<tr class="memdesc:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5713f69c26a9ad3de006438c59719bd9 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5713f69c26a9ad3de006438c59719bd9"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a5713f69c26a9ad3de006438c59719bd9">begin</a> () const </td></tr>
<tr class="memdesc:a5713f69c26a9ad3de006438c59719bd9 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a5713f69c26a9ad3de006438c59719bd9 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69de72bc79e00f944f5f5eb198a39a0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac69de72bc79e00f944f5f5eb198a39a0"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ac69de72bc79e00f944f5f5eb198a39a0">cbegin</a> () const </td></tr>
<tr class="memdesc:ac69de72bc79e00f944f5f5eb198a39a0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ac69de72bc79e00f944f5f5eb198a39a0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af350224256d13022cc13025597668139 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af350224256d13022cc13025597668139"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#af350224256d13022cc13025597668139">end</a> ()</td></tr>
<tr class="memdesc:af350224256d13022cc13025597668139 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:af350224256d13022cc13025597668139 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774669f3df983ed43dac9c1836324d71 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a774669f3df983ed43dac9c1836324d71"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a774669f3df983ed43dac9c1836324d71">end</a> () const </td></tr>
<tr class="memdesc:a774669f3df983ed43dac9c1836324d71 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a774669f3df983ed43dac9c1836324d71 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f91acba898cc61ad044359670bfe27 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59f91acba898cc61ad044359670bfe27"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a59f91acba898cc61ad044359670bfe27">cend</a> () const </td></tr>
<tr class="memdesc:a59f91acba898cc61ad044359670bfe27 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a59f91acba898cc61ad044359670bfe27 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51afff99d91ece7435020b6715697b91 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">insert</a> (<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a51afff99d91ece7435020b6715697b91 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a51afff99d91ece7435020b6715697b91">More...</a><br /></td></tr>
<tr class="separator:a51afff99d91ece7435020b6715697b91 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">insert</a> (<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a8cce1422756e1f63a84f67c5a78d9553">More...</a><br /></td></tr>
<tr class="separator:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff093722108876219c6210d7e730fd25 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aff093722108876219c6210d7e730fd25 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aff093722108876219c6210d7e730fd25">ensure</a> (<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:aff093722108876219c6210d7e730fd25 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#aff093722108876219c6210d7e730fd25">More...</a><br /></td></tr>
<tr class="separator:aff093722108876219c6210d7e730fd25 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">unlink</a> (<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#a6c0561887682f47f5358170b6a87ca18">More...</a><br /></td></tr>
<tr class="separator:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a90b615614b9ee394bd38a60d71bb4156">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with specified <code>key</code>.  <a href="#a90b615614b9ee394bd38a60d71bb4156">More...</a><br /></td></tr>
<tr class="separator:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a7e441df6f9fc2627e95d320ee6375871">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with comparing functor <code>pred</code>.  <a href="#a7e441df6f9fc2627e95d320ee6375871">More...</a><br /></td></tr>
<tr class="separator:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a95ba518ea3321e4d0434b62ebeb6e19c">extract_min</a> ()</td></tr>
<tr class="memdesc:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the list.  <a href="#a95ba518ea3321e4d0434b62ebeb6e19c">More...</a><br /></td></tr>
<tr class="separator:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a5e17af7064fa115bb4ef40789beac714">extract_max</a> ()</td></tr>
<tr class="memdesc:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the list.  <a href="#a5e17af7064fa115bb4ef40789beac714">More...</a><br /></td></tr>
<tr class="separator:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a442cc388b70130898a6a40e53e5286b6">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a442cc388b70130898a6a40e53e5286b6">More...</a><br /></td></tr>
<tr class="separator:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ad7e1caa5f872abb2fd071c6b6d43f016">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#ad7e1caa5f872abb2fd071c6b6d43f016">More...</a><br /></td></tr>
<tr class="separator:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a1831116fe2eaea39643d3fcb65371d5b">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a1831116fe2eaea39643d3fcb65371d5b">More...</a><br /></td></tr>
<tr class="separator:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a06b7ec55a6a3f0005cbf03a3829a67c7">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a06b7ec55a6a3f0005cbf03a3829a67c7">More...</a><br /></td></tr>
<tr class="separator:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a3dc70165841bf8871caed0a1f8c0dece">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="#a3dc70165841bf8871caed0a1f8c0dece">More...</a><br /></td></tr>
<tr class="separator:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aa90bce91b752b0998e66fc3e7ed403b6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="#aa90bce91b752b0998e66fc3e7ed403b6">More...</a><br /></td></tr>
<tr class="separator:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064594beb4dda9c907797c9866ef14a inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a3064594beb4dda9c907797c9866ef14a inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a3064594beb4dda9c907797c9866ef14a">find</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a3064594beb4dda9c907797c9866ef14a inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="#a3064594beb4dda9c907797c9866ef14a">More...</a><br /></td></tr>
<tr class="separator:a3064594beb4dda9c907797c9866ef14a inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e53b01ddc9dcc1f712822d56681278e inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a3e53b01ddc9dcc1f712822d56681278e inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a3e53b01ddc9dcc1f712822d56681278e">find_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a3e53b01ddc9dcc1f712822d56681278e inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> with comparing functor <code>pred</code>.  <a href="#a3e53b01ddc9dcc1f712822d56681278e">More...</a><br /></td></tr>
<tr class="separator:a3e53b01ddc9dcc1f712822d56681278e inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a6ba7de0d4e7a8f1097c481f46b7a1ca0">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a6ba7de0d4e7a8f1097c481f46b7a1ca0">More...</a><br /></td></tr>
<tr class="separator:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a516aac70e4451b8b1df59510e0bdd6bc">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a516aac70e4451b8b1df59510e0bdd6bc">More...</a><br /></td></tr>
<tr class="separator:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43241fb0c5805c1e2358695d29bbb8aa inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a43241fb0c5805c1e2358695d29bbb8aa">size</a> () const </td></tr>
<tr class="memdesc:a43241fb0c5805c1e2358695d29bbb8aa inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a43241fb0c5805c1e2358695d29bbb8aa">More...</a><br /></td></tr>
<tr class="separator:a43241fb0c5805c1e2358695d29bbb8aa inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee308a445474535e243b8aed0c804eb8 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee308a445474535e243b8aed0c804eb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aee308a445474535e243b8aed0c804eb8">empty</a> () const </td></tr>
<tr class="memdesc:aee308a445474535e243b8aed0c804eb8 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br /></td></tr>
<tr class="separator:aee308a445474535e243b8aed0c804eb8 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">clear</a> ()</td></tr>
<tr class="memdesc:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic)  <a href="#a28947a855f1e0e702da233287eb3c59f">More...</a><br /></td></tr>
<tr class="separator:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506ebd8ef00f13f16656c2d7289e318 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7506ebd8ef00f13f16656c2d7289e318"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a7506ebd8ef00f13f16656c2d7289e318">statistics</a> () const </td></tr>
<tr class="memdesc:a7506ebd8ef00f13f16656c2d7289e318 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a7506ebd8ef00f13f16656c2d7289e318 inherit pro_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_singletoncds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a891742e136dd2a31a2bdc80ecfdf73f4"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a891742e136dd2a31a2bdc80ecfdf73f4">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br /></td></tr>
<tr class="separator:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a39922ef253f44e1819b8978960d322d4 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39922ef253f44e1819b8978960d322d4"></a>
skip_list::details::head_node<br class="typebreak" />
&lt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a39922ef253f44e1819b8978960d322d4">m_Head</a></td></tr>
<tr class="memdesc:a39922ef253f44e1819b8978960d322d4 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">head tower (max height) <br /></td></tr>
<tr class="separator:a39922ef253f44e1819b8978960d322d4 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc703c6d8a9bd616bda30d4e6ee123f inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dc703c6d8a9bd616bda30d4e6ee123f"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ad5ba2cd482243590355f3e07f31d5410">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a5dc703c6d8a9bd616bda30d4e6ee123f">m_ItemCounter</a></td></tr>
<tr class="memdesc:a5dc703c6d8a9bd616bda30d4e6ee123f inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a5dc703c6d8a9bd616bda30d4e6ee123f inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ada9d69f190d886789b15ca908baa87 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ada9d69f190d886789b15ca908baa87"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a1af8cf6e792b254e40124b677f946913">random_level_generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a0ada9d69f190d886789b15ca908baa87">m_RandomLevelGen</a></td></tr>
<tr class="memdesc:a0ada9d69f190d886789b15ca908baa87 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator instance <br /></td></tr>
<tr class="separator:a0ada9d69f190d886789b15ca908baa87 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada09259d7fc51c906256c7fd44910887 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada09259d7fc51c906256c7fd44910887"></a>
atomics::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ada09259d7fc51c906256c7fd44910887">m_nHeight</a></td></tr>
<tr class="memdesc:ada09259d7fc51c906256c7fd44910887 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimated high level <br /></td></tr>
<tr class="separator:ada09259d7fc51c906256c7fd44910887 inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1e5ed762fe91e25e6d43915331f2ea inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1e5ed762fe91e25e6d43915331f2ea"></a>
<a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a3d1e5ed762fe91e25e6d43915331f2ea">m_Stat</a></td></tr>
<tr class="memdesc:a3d1e5ed762fe91e25e6d43915331f2ea inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:a3d1e5ed762fe91e25e6d43915331f2ea inherit pro_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_singletoncds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">c_nMaxHeight</a></td></tr>
<tr class="memdesc:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="#a92a0f389d6be4dd2dc2ea005aa49e79e">More...</a><br /></td></tr>
<tr class="separator:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_singletoncds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt;<br />
class cds::container::SkipListSet&lt; GC, T, Traits &gt;</h3>

<p>Lock-free skip-list set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_hp"></a> The implementation of well-known probabilistic data structure called skip-list invented by W.Pugh in his papers:</p><ul>
<li>[1989] W.Pugh Skip Lists: A Probabilistic Alternative to Balanced Trees</li>
<li>[1990] W.Pugh A Skip List Cookbook</li>
</ul>
<p>A skip-list is a probabilistic data structure that provides expected logarithmic time search without the need of rebalance. The skip-list is a collection of sorted linked list. Nodes are ordered by key. Each node is linked into a subset of the lists. Each list has a level, ranging from 0 to 32. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each node is created with a random top level (with a random height), and belongs to all lists up to that level. The probability that a node has the height 1 is 1/2. The probability that a node has the height N is 1/2 ** N (more precisely, the distribution depends on an random generator provided, but our generators have this property).</p>
<p>The lock-free variant of skip-list is implemented according to book</p><ul>
<li>[2008] M.Herlihy, N.Shavit "The Art of Multiprocessor Programming", chapter 14.4 "A Lock-Free Concurrent Skiplist"</li>
</ul>
<p>Template arguments:</p><ul>
<li><code>GC</code> - Garbage collector used.</li>
<li><code>T</code> - type to be stored in the list.</li>
<li><code>Traits</code> - set traits, default is <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1traits.html" title="SkipListSet traits. ">skip_list::traits</a></code>. It is possible to declare option-based list with <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits. ">cds::container::skip_list::make_traits</a></code> metafunction istead of <code>Traits</code> template argument.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The skip-list requires up to 67 hazard pointers that may be critical for some GCs for which the guard count is limited (like as <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>). Those GCs should be explicitly initialized with hazard pointer enough:<div class="fragment"><div class="line">cds::gc::HP myhp( 67 ) </div>
</div><!-- fragment -->. Otherwise an run-time exception may be raised when you try to create skip-list object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are several specializations of <code>SkipListSet</code> for each <code>GC</code>. You should include:<ul>
<li><code>&lt;cds/container/skip_list_set_hp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code> garbage collector</li>
<li><code>&lt;cds/container/skip_list_set_dhp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a></code> garbage collector</li>
<li><code>&lt;cds/container/skip_list_set_rcu.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListSet_rcu">RCU type</a></li>
<li><code>&lt;cds/container/skip_list_set_nogc.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_set_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListSet_nogc">non-deletable SkipListSet</a></li>
</ul>
</dd></dl>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> and <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>). The iteration is ordered. The iterator object is thread-safe: the element pointed by the iterator object is guarded, so, the element cannot be reclaimed while the iterator object is alive. However, passing an iterator object between threads is dangerous.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to concurrent nature of skip-list set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purpose only</dd></dl>
<p>Remember, each iterator object requires 2 additional hazard pointers, that may be a limited resource for <code>GC</code> like <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code> (for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a></code> the count of guards is unlimited).</p>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>( <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> <span class="keyword">const</span>&amp; s);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&amp; operator ++();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&amp; src);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <code><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a2a35161588bd79205c81b84919c7722c" title="Returns a forward iterator that addresses the location succeeding the last element in a set...">end()</a></code>, <code><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a7b01b76929db72627903bd20addccb9e" title="Returns a forward const iterator that addresses the location succeeding the last element in a set...">cend()</a></code> member functions points to <code>nullptr</code> and should not be dereferenced. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9bae06c446486a883e3bf8cd9c65950d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::<a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="cds_containewr_SkipListSet_value_type"></a>Value type to be stored in the set </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f3b2f71972becaa6a28de52ef3956bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (not atomic). </p>
<p>The function deletes all items from the set. The function is not atomic, thus, in multi-threaded environment with parallel insertions this sequence </p><div class="fragment"><div class="line">set.clear();</div>
<div class="line">assert( set.empty() );</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each item the <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html#ae9b394b2f922a1400b2eb2c3e6b2bacc">disposer</a> provided by <code>Traits</code> template parameter will be called. </p>

</div>
</div>
<a class="anchor" id="adb97ed3e2b3a677fb0a9abbf9025477e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a28831477fa76661cfeb2fe4884ef025c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the item exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div>
</div><!-- fragment --><p> or a functor: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>key</code> passed into the <code>ensure</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4e9e93f23fe55fc1a13c0998dc2267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_erase_val"></a> The set item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aa2542991a0a9f2348c9b6c5cca0ae1a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> <span class="keyword">const</span>&amp; val);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Since the key of <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> defines the key type to search in the list. The list item comparator should be able to compare the type <code>T</code> of list item and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a52388afd06ea35ed1cbd785dba52ac0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ae6bf176ad8950298a770a801f5bd68bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="aab2284cfd210c096378fe7c86157290c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the set with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_hp_extract"></a>The function searches an item with key equal to <code>key</code> in the set, unlinks it from the set, and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The item extracted is freed automatically by garbage collector <code>GC</code> when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet&lt; cds::gc::HP, foo, my_traits &gt;</a>  skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    skip_list::guarded_ptr gp(theList.extract( 5 ))</div>
<div class="line">    <span class="keywordflow">if</span> (  gp ) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and frees the pointer</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5d471ab598f474a25ff8fb8930960f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the set. </p>
<p>The function searches an item with maximal key, unlinks it, and returns the pointer to item found as <code>guarded_ptr</code>. If the skip-list is empty the function returns an empty guarded pointer.</p>
<p>The item found is freed by garbage collector <code>GC</code> automatically when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet&lt; cds::gc::HP, foo, my_traits &gt;</a>  skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    skip_list::guarded_ptr gp( theList.extract_max());</div>
<div class="line">    <span class="keywordflow">if</span> ( gp ) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and then frees the pointer</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad95f728e6e8f7f78a29a16912a890bb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the set. </p>
<p>The function searches an item with minimal key, unlinks it, and returns pointer to the item found as <code>guarded_ptr</code>. If the skip-list is empty the function returns an empty guarded pointer.</p>
<p>The item extracted is freed automatically by garbage collector <code>GC</code> when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::continer::SkipListSet&lt; cds::gc::HP, foo, my_traits &gt;  skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    skip_list::guarded_ptr gp( theList.extract_min());</div>
<div class="line">    <span class="keywordflow">if</span> ( gp ) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and then frees the pointer</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acb845ff13864d403412b08dd897599d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the set with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_hp_extract">extract(Q const&amp;)</a> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ab7464492eb3755390cb4bda3c82f8b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, Q&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a98eaad8e589246d4e7c83814a6066826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a808f79ca28e33da97182166d4f0b1110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a5f1675214d411e8d7d7a6d51ea536b00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a9d1806975cd89b92067fdce2a1665447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_hp_get"></a>The function searches the item with key equal to <code>key</code> and returns a guarded pointer to the item found. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>It is safe when a concurrent thread erases the item returned in <code>result</code> guarded pointer. In this case the item will be freed later by garbage collector <code>GC</code> automatically when <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet&lt; cds::gc::HP, foo, my_traits &gt;</a>  skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    skip_list::guarded_ptr gp( theList.get( 5 ));</div>
<div class="line">    <span class="keywordflow">if</span> ( theList.get( 5 )) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the compare functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a class="anchor" id="a128d744ba364f91fdd733284659d2565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a96c912a4c58cfa22165e7d7807d79b2d">guarded_ptr</a> <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_hp_get">get(Q const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a58e9f24060a29d05a775108a323b804b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4f437617d9f9b09b0fc6358b3471bbe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-fields of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="singletoncds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a class="anchor" id="a3cfdb785d05781a79097c8d289392ae6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> this function always returns 0. Therefore, the function is not suitable for checking the set emptiness, use <code><a class="el" href="singletoncds_1_1container_1_1_skip_list_set.html#af6994d9dcb9b7fb2b339833107efceaf" title="Checks if the set is empty. ">empty()</a></code> member function for this purpose. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cds/container/details/skip_list_base.h</li>
<li>cds/container/impl/skip_list_set.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:22 by Doxygen 1.8.8</i>
</div>
</body>
</html>
