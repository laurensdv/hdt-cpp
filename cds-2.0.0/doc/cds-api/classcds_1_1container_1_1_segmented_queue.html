<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::container::SegmentedQueue&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html">SegmentedQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SegmentedQueue&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__queue.html">Queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Segmented queue.  
 <a href="classcds_1_1container_1_1_segmented_queue.html#details">More...</a></p>

<p><code>#include &lt;cds/container/segmented_queue.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SegmentedQueue&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_segmented_queue.png" usemap="#cds::container::SegmentedQueue&lt; GC, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::SegmentedQueue&lt; GC, T, Traits &gt;_map" name="cds::container::SegmentedQueue&lt; GC, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_segmented_queue.html" title="Segmented queue. " alt="cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;" shape="rect" coords="0,0,295,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a59826927713723924eff80a9a7f08bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59826927713723924eff80a9a7f08bfb"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a59826927713723924eff80a9a7f08bfb">gc</a></td></tr>
<tr class="memdesc:a59826927713723924eff80a9a7f08bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a59826927713723924eff80a9a7f08bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883d4d55057800bdd4b607602ed76060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a883d4d55057800bdd4b607602ed76060"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a></td></tr>
<tr class="memdesc:a883d4d55057800bdd4b607602ed76060"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the value stored in the queue <br /></td></tr>
<tr class="separator:a883d4d55057800bdd4b607602ed76060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd924efe0fd69d05949774ca12877a3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd924efe0fd69d05949774ca12877a3b"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#afd924efe0fd69d05949774ca12877a3b">traits</a></td></tr>
<tr class="memdesc:afd924efe0fd69d05949774ca12877a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue traits. <br /></td></tr>
<tr class="separator:afd924efe0fd69d05949774ca12877a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471b48a9c3fa634f691f9e7a63eff8d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471b48a9c3fa634f691f9e7a63eff8d8"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a471b48a9c3fa634f691f9e7a63eff8d8">node_allocator</a></td></tr>
<tr class="memdesc:a471b48a9c3fa634f691f9e7a63eff8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator. <br /></td></tr>
<tr class="separator:a471b48a9c3fa634f691f9e7a63eff8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d5bd97d8e04bd37404acd81d78c62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af12d5bd97d8e04bd37404acd81d78c62"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#af12d5bd97d8e04bd37404acd81d78c62">memory_model</a></td></tr>
<tr class="memdesc:af12d5bd97d8e04bd37404acd81d78c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:af12d5bd97d8e04bd37404acd81d78c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2cf07cf36bafadccc7b510d32c761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf2cf07cf36bafadccc7b510d32c761"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#afbf2cf07cf36bafadccc7b510d32c761">item_counter</a></td></tr>
<tr class="memdesc:afbf2cf07cf36bafadccc7b510d32c761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy, see <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">cds::opt::item_counter</a> option setter. <br /></td></tr>
<tr class="separator:afbf2cf07cf36bafadccc7b510d32c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdb5f79369b42a242228cea23c7e510"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbdb5f79369b42a242228cea23c7e510"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#acbdb5f79369b42a242228cea23c7e510">stat</a></td></tr>
<tr class="memdesc:acbdb5f79369b42a242228cea23c7e510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy. <br /></td></tr>
<tr class="separator:acbdb5f79369b42a242228cea23c7e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f2d482ad3c5a90ab74e20b00a95a00b"></a>
typedef base_class::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a8f2d482ad3c5a90ab74e20b00a95a00b">lock_type</a></td></tr>
<tr class="memdesc:a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of mutex for maintaining an internal list of allocated segments. <br /></td></tr>
<tr class="separator:a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8088cbf1759789823b681ad3e07eec27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8088cbf1759789823b681ad3e07eec27"></a>
typedef <br class="typebreak" />
base_class::permutation_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a8088cbf1759789823b681ad3e07eec27">permutation_generator</a></td></tr>
<tr class="memdesc:a8088cbf1759789823b681ad3e07eec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random permutation generator for sequence [0, quasi-factor) <br /></td></tr>
<tr class="separator:a8088cbf1759789823b681ad3e07eec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_segmented_queue')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a018256bb2afa8f6275854a7dba3ec55d inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018256bb2afa8f6275854a7dba3ec55d"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a018256bb2afa8f6275854a7dba3ec55d">gc</a></td></tr>
<tr class="memdesc:a018256bb2afa8f6275854a7dba3ec55d inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a018256bb2afa8f6275854a7dba3ec55d inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68ad757bbb48525397c39299565fde inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada68ad757bbb48525397c39299565fde"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a></td></tr>
<tr class="memdesc:ada68ad757bbb48525397c39299565fde inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the value stored in the queue <br /></td></tr>
<tr class="separator:ada68ad757bbb48525397c39299565fde inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f505d4d990d1b4401c59ac9cd50c6 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5f505d4d990d1b4401c59ac9cd50c6"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a8b5f505d4d990d1b4401c59ac9cd50c6">traits</a></td></tr>
<tr class="memdesc:a8b5f505d4d990d1b4401c59ac9cd50c6 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue traits. <br /></td></tr>
<tr class="separator:a8b5f505d4d990d1b4401c59ac9cd50c6 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf619d38702a8a4cd635acbb800f0d05 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf619d38702a8a4cd635acbb800f0d05"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#abf619d38702a8a4cd635acbb800f0d05">disposer</a></td></tr>
<tr class="memdesc:abf619d38702a8a4cd635acbb800f0d05 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">value disposer, called only in <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#afee9d88ec841e1d0be906e663bd42583" title="Clear the queue. ">clear()</a></code> when the element to be dequeued <br /></td></tr>
<tr class="separator:abf619d38702a8a4cd635acbb800f0d05 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6a573283848be605468a47ee0cf42 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae6a573283848be605468a47ee0cf42"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a7ae6a573283848be605468a47ee0cf42">allocator</a></td></tr>
<tr class="memdesc:a7ae6a573283848be605468a47ee0cf42 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator maintaining the segments. <br /></td></tr>
<tr class="separator:a7ae6a573283848be605468a47ee0cf42 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5614453d4f178ad7c049f04f225d298 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5614453d4f178ad7c049f04f225d298"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac5614453d4f178ad7c049f04f225d298">memory_model</a></td></tr>
<tr class="memdesc:ac5614453d4f178ad7c049f04f225d298 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:ac5614453d4f178ad7c049f04f225d298 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335dcf76c72477d0465dbbfd07b3225f inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a335dcf76c72477d0465dbbfd07b3225f"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a335dcf76c72477d0465dbbfd07b3225f">item_counter</a></td></tr>
<tr class="memdesc:a335dcf76c72477d0465dbbfd07b3225f inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy, see <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">cds::opt::item_counter</a> option setter. <br /></td></tr>
<tr class="separator:a335dcf76c72477d0465dbbfd07b3225f inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471a3dee01e363dccef7a35586ad55c2 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471a3dee01e363dccef7a35586ad55c2"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a></td></tr>
<tr class="memdesc:a471a3dee01e363dccef7a35586ad55c2 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy. <br /></td></tr>
<tr class="separator:a471a3dee01e363dccef7a35586ad55c2 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e33760ff11827c436068b657f039afd inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e33760ff11827c436068b657f039afd"></a>
typedef traits::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a2e33760ff11827c436068b657f039afd">lock_type</a></td></tr>
<tr class="memdesc:a2e33760ff11827c436068b657f039afd inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of mutex for maintaining an internal list of allocated segments. <br /></td></tr>
<tr class="separator:a2e33760ff11827c436068b657f039afd inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80618173d005e2059850b16f36a60098 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80618173d005e2059850b16f36a60098"></a>
typedef <br class="typebreak" />
traits::permutation_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a80618173d005e2059850b16f36a60098">permutation_generator</a></td></tr>
<tr class="memdesc:a80618173d005e2059850b16f36a60098 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random permutation generator for sequence [0, quasi-factor) <br /></td></tr>
<tr class="separator:a80618173d005e2059850b16f36a60098 inherit pub_types_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a3f6a0c367d9fa4b92663e5d2d8c4c10a">SegmentedQueue</a> (size_t nQuasiFactor)</td></tr>
<tr class="memdesc:a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the empty queue.  <a href="#a3f6a0c367d9fa4b92663e5d2d8c4c10a">More...</a><br /></td></tr>
<tr class="separator:a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bbdefa56194fb90c37f66ea160126a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98bbdefa56194fb90c37f66ea160126a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a98bbdefa56194fb90c37f66ea160126a">~SegmentedQueue</a> ()</td></tr>
<tr class="memdesc:a98bbdefa56194fb90c37f66ea160126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue and deletes all internal data. <br /></td></tr>
<tr class="separator:a98bbdefa56194fb90c37f66ea160126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#aada9d85d68dcf1293c9eadf03b2e4ecd">enqueue</a> (<a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at last segment of the queue.  <a href="#aada9d85d68dcf1293c9eadf03b2e4ecd">More...</a><br /></td></tr>
<tr class="separator:aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a19fd9b1e189ecfefb3fe7dbe8718c529">enqueue_with</a> (Func f)</td></tr>
<tr class="memdesc:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues data to the queue using a functor.  <a href="#a19fd9b1e189ecfefb3fe7dbe8718c529">More...</a><br /></td></tr>
<tr class="separator:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35bcc292299af2a5ae13129e11f62f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac35bcc292299af2a5ae13129e11f62f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#ac35bcc292299af2a5ae13129e11f62f7">push</a> (<a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:ac35bcc292299af2a5ae13129e11f62f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#aada9d85d68dcf1293c9eadf03b2e4ecd" title="Inserts a new element at last segment of the queue. ">enqueue()</a></code> member function. <br /></td></tr>
<tr class="separator:ac35bcc292299af2a5ae13129e11f62f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f49fd6f8db730c0b2253767c34724a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70f49fd6f8db730c0b2253767c34724a"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a70f49fd6f8db730c0b2253767c34724a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a70f49fd6f8db730c0b2253767c34724a">push_with</a> (Func f)</td></tr>
<tr class="memdesc:a70f49fd6f8db730c0b2253767c34724a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a19fd9b1e189ecfefb3fe7dbe8718c529" title="Enqueues data to the queue using a functor. ">enqueue_with()</a></code> member function. <br /></td></tr>
<tr class="separator:a70f49fd6f8db730c0b2253767c34724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5251921347d5a12844a28a788af06b69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5251921347d5a12844a28a788af06b69"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5251921347d5a12844a28a788af06b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a5251921347d5a12844a28a788af06b69">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5251921347d5a12844a28a788af06b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues data of type <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> <br /></td></tr>
<tr class="separator:a5251921347d5a12844a28a788af06b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a625c6917029a03b6ba788ce658ceec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a8a625c6917029a03b6ba788ce658ceec">dequeue</a> (<a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a8a625c6917029a03b6ba788ce658ceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value from the queue.  <a href="#a8a625c6917029a03b6ba788ce658ceec">More...</a><br /></td></tr>
<tr class="separator:a8a625c6917029a03b6ba788ce658ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6492f153a1550d06bad6553ed45e62"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a3d6492f153a1550d06bad6553ed45e62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a3d6492f153a1550d06bad6553ed45e62">dequeue_with</a> (Func f)</td></tr>
<tr class="memdesc:a3d6492f153a1550d06bad6553ed45e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value using a functor.  <a href="#a3d6492f153a1550d06bad6553ed45e62">More...</a><br /></td></tr>
<tr class="separator:a3d6492f153a1550d06bad6553ed45e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e78346d948abde6b8f7f97f0ef08fee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e78346d948abde6b8f7f97f0ef08fee"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a6e78346d948abde6b8f7f97f0ef08fee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a6e78346d948abde6b8f7f97f0ef08fee">pop_with</a> (Func f)</td></tr>
<tr class="memdesc:a6e78346d948abde6b8f7f97f0ef08fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a3d6492f153a1550d06bad6553ed45e62" title="Dequeues a value using a functor. ">dequeue_with()</a></code> function. <br /></td></tr>
<tr class="separator:a6e78346d948abde6b8f7f97f0ef08fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e22d05bef8070c2edeb3fac666607f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5e22d05bef8070c2edeb3fac666607f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#af5e22d05bef8070c2edeb3fac666607f">pop</a> (<a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:af5e22d05bef8070c2edeb3fac666607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46" title="Removes an element from first segment of the queue and returns it. ">dequeue()</a></code> function. <br /></td></tr>
<tr class="separator:af5e22d05bef8070c2edeb3fac666607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f2881687fbef51924148cf91bedbaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a35f2881687fbef51924148cf91bedbaa">empty</a> () const </td></tr>
<tr class="memdesc:a35f2881687fbef51924148cf91bedbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="#a35f2881687fbef51924148cf91bedbaa">More...</a><br /></td></tr>
<tr class="separator:a35f2881687fbef51924148cf91bedbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90185a12f72dcb4beb2de01fca1cd54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#ae90185a12f72dcb4beb2de01fca1cd54">clear</a> ()</td></tr>
<tr class="memdesc:ae90185a12f72dcb4beb2de01fca1cd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#ae90185a12f72dcb4beb2de01fca1cd54">More...</a><br /></td></tr>
<tr class="separator:ae90185a12f72dcb4beb2de01fca1cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c430fb0982d586df25d6f17632b9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c430fb0982d586df25d6f17632b9bb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a14c430fb0982d586df25d6f17632b9bb">size</a> () const </td></tr>
<tr class="memdesc:a14c430fb0982d586df25d6f17632b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count. <br /></td></tr>
<tr class="separator:a14c430fb0982d586df25d6f17632b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc20c03ee6b82b48f19e1b1a71e52a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#acbdb5f79369b42a242228cea23c7e510">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a9bc20c03ee6b82b48f19e1b1a71e52a7">statistics</a> () const </td></tr>
<tr class="memdesc:a9bc20c03ee6b82b48f19e1b1a71e52a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics.  <a href="#a9bc20c03ee6b82b48f19e1b1a71e52a7">More...</a><br /></td></tr>
<tr class="separator:a9bc20c03ee6b82b48f19e1b1a71e52a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9cdb406349f87cae76b79d2b35a563"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c9cdb406349f87cae76b79d2b35a563"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a8c9cdb406349f87cae76b79d2b35a563">quasi_factor</a> () const </td></tr>
<tr class="memdesc:a8c9cdb406349f87cae76b79d2b35a563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quasi factor, a power-of-two number. <br /></td></tr>
<tr class="separator:a8c9cdb406349f87cae76b79d2b35a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_segmented_queue')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a7c4fd1d98114ea90334a750cd129c98d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a7c4fd1d98114ea90334a750cd129c98d">SegmentedQueue</a> (size_t nQuasiFactor)</td></tr>
<tr class="memdesc:a7c4fd1d98114ea90334a750cd129c98d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the empty queue.  <a href="#a7c4fd1d98114ea90334a750cd129c98d">More...</a><br /></td></tr>
<tr class="separator:a7c4fd1d98114ea90334a750cd129c98d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b05b53ee11731d9f54e8bd2b9c09e inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363b05b53ee11731d9f54e8bd2b9c09e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a363b05b53ee11731d9f54e8bd2b9c09e">~SegmentedQueue</a> ()</td></tr>
<tr class="memdesc:a363b05b53ee11731d9f54e8bd2b9c09e inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue and deletes all internal data. <br /></td></tr>
<tr class="separator:a363b05b53ee11731d9f54e8bd2b9c09e inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23898b0b773dfefbcb618a889347c3d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23898b0b773dfefbcb618a889347c3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac23898b0b773dfefbcb618a889347c3d">enqueue</a> (<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac23898b0b773dfefbcb618a889347c3d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at last segment of the queue. <br /></td></tr>
<tr class="separator:ac23898b0b773dfefbcb618a889347c3d inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527ba06eafde4f54bfa6e855f1fba46 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46">dequeue</a> ()</td></tr>
<tr class="memdesc:af527ba06eafde4f54bfa6e855f1fba46 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from first segment of the queue and returns it.  <a href="#af527ba06eafde4f54bfa6e855f1fba46">More...</a><br /></td></tr>
<tr class="separator:af527ba06eafde4f54bfa6e855f1fba46 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f1f6d2ceab34776516aff23732e8f inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac64f1f6d2ceab34776516aff23732e8f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac64f1f6d2ceab34776516aff23732e8f">push</a> (<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac64f1f6d2ceab34776516aff23732e8f inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac23898b0b773dfefbcb618a889347c3d" title="Inserts a new element at last segment of the queue. ">enqueue(value_type&amp;)</a></code> member function. <br /></td></tr>
<tr class="separator:ac64f1f6d2ceab34776516aff23732e8f inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85272b6a439ee0942b5e9520b98d1d13 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85272b6a439ee0942b5e9520b98d1d13"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a85272b6a439ee0942b5e9520b98d1d13">pop</a> ()</td></tr>
<tr class="memdesc:a85272b6a439ee0942b5e9520b98d1d13 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46" title="Removes an element from first segment of the queue and returns it. ">dequeue()</a></code> member function. <br /></td></tr>
<tr class="separator:a85272b6a439ee0942b5e9520b98d1d13 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c4870334e4bd33547cde391df7de15 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a71c4870334e4bd33547cde391df7de15">empty</a> () const </td></tr>
<tr class="memdesc:a71c4870334e4bd33547cde391df7de15 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="#a71c4870334e4bd33547cde391df7de15">More...</a><br /></td></tr>
<tr class="separator:a71c4870334e4bd33547cde391df7de15 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9d88ec841e1d0be906e663bd42583 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#afee9d88ec841e1d0be906e663bd42583">clear</a> ()</td></tr>
<tr class="memdesc:afee9d88ec841e1d0be906e663bd42583 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#afee9d88ec841e1d0be906e663bd42583">More...</a><br /></td></tr>
<tr class="separator:afee9d88ec841e1d0be906e663bd42583 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9175386dac61a025d6b60f5d7a80ef inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr class="memitem:a1c9175386dac61a025d6b60f5d7a80ef inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a1c9175386dac61a025d6b60f5d7a80ef">clear_with</a> (Disposer)</td></tr>
<tr class="memdesc:a1c9175386dac61a025d6b60f5d7a80ef inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a1c9175386dac61a025d6b60f5d7a80ef">More...</a><br /></td></tr>
<tr class="separator:a1c9175386dac61a025d6b60f5d7a80ef inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c763ebbcc9fc3edb148a282d2e83ea inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c763ebbcc9fc3edb148a282d2e83ea"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a13c763ebbcc9fc3edb148a282d2e83ea">size</a> () const </td></tr>
<tr class="memdesc:a13c763ebbcc9fc3edb148a282d2e83ea inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count. <br /></td></tr>
<tr class="separator:a13c763ebbcc9fc3edb148a282d2e83ea inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441f996643963423cf8a9ad041c8faf6 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a441f996643963423cf8a9ad041c8faf6">statistics</a> () const </td></tr>
<tr class="memdesc:a441f996643963423cf8a9ad041c8faf6 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics.  <a href="#a441f996643963423cf8a9ad041c8faf6">More...</a><br /></td></tr>
<tr class="separator:a441f996643963423cf8a9ad041c8faf6 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b503d61f87be1f83642d1cb5edbe57 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b503d61f87be1f83642d1cb5edbe57"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a86b503d61f87be1f83642d1cb5edbe57">quasi_factor</a> () const </td></tr>
<tr class="memdesc:a86b503d61f87be1f83642d1cb5edbe57 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quasi factor, a power-of-two number. <br /></td></tr>
<tr class="separator:a86b503d61f87be1f83642d1cb5edbe57 inherit pub_methods_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a40999e5c24922f65bbe89dfc7c79df03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40999e5c24922f65bbe89dfc7c79df03"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a40999e5c24922f65bbe89dfc7c79df03">m_nHazardPtrCount</a> = base_class::m_nHazardPtrCount</td></tr>
<tr class="memdesc:a40999e5c24922f65bbe89dfc7c79df03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a40999e5c24922f65bbe89dfc7c79df03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1intrusive_1_1_segmented_queue')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a47b4fc8634e24dc94bb733cde8694c0d inherit pub_static_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b4fc8634e24dc94bb733cde8694c0d"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a47b4fc8634e24dc94bb733cde8694c0d">m_nHazardPtrCount</a> = 2</td></tr>
<tr class="memdesc:a47b4fc8634e24dc94bb733cde8694c0d inherit pub_static_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a47b4fc8634e24dc94bb733cde8694c0d inherit pub_static_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_segmented_queue')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a4e578806b102817a766e8df7d6ff4d74 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e578806b102817a766e8df7d6ff4d74"></a>
segment_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a4e578806b102817a766e8df7d6ff4d74">m_SegmentList</a></td></tr>
<tr class="memdesc:a4e578806b102817a766e8df7d6ff4d74 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of segments. <br /></td></tr>
<tr class="separator:a4e578806b102817a766e8df7d6ff4d74 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6368e394b9f4c33600d204b1cd51603 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6368e394b9f4c33600d204b1cd51603"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a335dcf76c72477d0465dbbfd07b3225f">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ab6368e394b9f4c33600d204b1cd51603">m_ItemCounter</a></td></tr>
<tr class="memdesc:ab6368e394b9f4c33600d204b1cd51603 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:ab6368e394b9f4c33600d204b1cd51603 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc7f8f9864de6707492b79a877ca970 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc7f8f9864de6707492b79a877ca970"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a5bc7f8f9864de6707492b79a877ca970">m_Stat</a></td></tr>
<tr class="memdesc:a5bc7f8f9864de6707492b79a877ca970 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a5bc7f8f9864de6707492b79a877ca970 inherit pro_attribs_classcds_1_1intrusive_1_1_segmented_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename T, typename Traits = segmented_queue::traits&gt;<br />
class cds::container::SegmentedQueue&lt; GC, T, Traits &gt;</h3>

<p>Segmented queue. </p>
<p>The queue is based on work</p><ul>
<li>[2010] Afek, Korland, Yanovsky "Quasi-Linearizability: relaxed consistency for improved concurrency"</li>
</ul>
<p>In this paper the authors offer a relaxed version of linearizability, so-called quasi-linearizability, that preserves some of the intuition, provides a flexible way to control the level of relaxation and supports th implementation of more concurrent and scalable data structure. Intuitively, the linearizability requires each run to be equivalent in some sense to a serial run of the algorithm. This equivalence to some serial run imposes strong synchronization requirements that in many cases results in limited scalability and synchronization bottleneck.</p>
<p>The general idea is that the queue maintains a linked list of segments, each segment is an array of nodes in the size of the quasi factor, and each node has a deleted boolean marker, which states if it has been dequeued. Each producer iterates over last segment in the linked list in some random permutation order. Whet it finds an empty cell it performs a CAS operation attempting to enqueue its new element. In case the entire segment has been scanned and no available cell is found (implying that the segment is full), then it attempts to add a new segment to the list.</p>
<p>The dequeue operation is similar: the consumer iterates over the first segment in the linked list in some random permutation order. When it finds an item which has not yet been dequeued, it performs CAS on its deleted marker in order to "delete" it, if succeeded this item is considered dequeued. In case the entire segment was scanned and all the nodes have already been dequeued (implying that the segment is empty), then it attempts to remove this segment from the linked list and starts the same process on the next segment. If there is no next segment, the queue is considered empty.</p>
<p>Based on the fact that most of the time threads do not add or remove segments, most of the work is done in parallel on different cells in the segments. This ensures a controlled contention depending on the segment size, which is quasi factor.</p>
<p>The segmented queue is an <em>unfair</em> queue since it violates the strong FIFO order but no more than quasi factor. It means that the consumer dequeues any item from the current first segment.</p>
<p>Template parameters:</p><ul>
<li><code>GC</code> - a garbage collector, possible types are <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">cds::gc::DHP</a></li>
<li><code>T</code> - the type of values stored in the queue</li>
<li><code>Traits</code> - queue type traits, default is <code><a class="el" href="structcds_1_1container_1_1segmented__queue_1_1traits.html" title="SegmentedQueue default type traits. ">segmented_queue::traits</a></code>. <code><a class="el" href="structcds_1_1container_1_1segmented__queue_1_1make__traits.html" title="Metafunction converting option list to traits for SegmentedQueue. ">segmented_queue::make_traits</a></code> metafunction can be used to construct your type traits. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3f6a0c367d9fa4b92663e5d2d8c4c10a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_segmented_queue.html">SegmentedQueue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nQuasiFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the empty queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nQuasiFactor</td><td>Quasi factor. If it is not a power of 2 it is rounded up to nearest power of 2. Minimum is 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae90185a12f72dcb4beb2de01fca1cd54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>The function repeatedly calls <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a8a625c6917029a03b6ba788ce658ceec">dequeue</a> until it returns <code>nullptr</code>. The disposer specified in <code>Traits</code> template argument is called for each removed item. </p>

</div>
</div>
<a class="anchor" id="a8a625c6917029a03b6ba788ce658ceec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value from the queue. </p>
<p>If queue is not empty, the function returns <code>true</code>, <code>dest</code> contains copy of dequeued value. The assignment operator for type <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> is invoked. If queue is empty, the function returns <code>false</code>, <code>dest</code> is unchanged. </p>

</div>
</div>
<a class="anchor" id="a3d6492f153a1550d06bad6553ed45e62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::dequeue_with </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value using a functor. </p>
<p><code>Func</code> is a functor called to copy dequeued value. The functor takes one argument - a reference to removed node: </p><div class="fragment"><div class="line"><a class="code" href="namespacecds.html">cds</a>:container::MSQueue&lt; cds::gc::HP, Foo &gt; myQueue;</div>
<div class="line">Bar bar;</div>
<div class="line">myQueue.<a class="code" href="classcds_1_1container_1_1_r_w_queue.html#aedf9662ade9094bdb86b9fd8929b6606">dequeue_with</a>( [&amp;bar]( Foo&amp; src ) { bar = std::move( src );});</div>
</div><!-- fragment --><p> The functor is called only if the queue is not empty. </p>

</div>
</div>
<a class="anchor" id="a35f2881687fbef51924148cf91bedbaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the queue is empty. </p>
<p>The original segmented queue algorithm does not allow to check emptiness accurately because <code><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a35f2881687fbef51924148cf91bedbaa" title="Checks if the queue is empty. ">empty()</a></code> is unlinearizable. This function tests queue's emptiness checking <code><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a14c430fb0982d586df25d6f17632b9bb" title="Returns queue&#39;s item count. ">size()</a> == 0</code>, so, the item counting feature is an essential part of queue's algorithm. </p>

</div>
</div>
<a class="anchor" id="aada9d85d68dcf1293c9eadf03b2e4ecd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at last segment of the queue. </p>
<p>The function makes queue node in dynamic memory calling copy constructor for <code>val</code> and then it calls intrusive::SEgmentedQueue::enqueue. Returns <code>true</code> if success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a19fd9b1e189ecfefb3fe7dbe8718c529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::enqueue_with </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues data to the queue using a functor. </p>
<p><code>Func</code> is a functor called to create node. The functor <code>f</code> takes one argument - a reference to a new node of type <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#a883d4d55057800bdd4b607602ed76060">value_type</a> : </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue&lt; cds::gc::HP, Foo &gt;</a> myQueue;</div>
<div class="line">Bar bar;</div>
<div class="line">myQueue.<a class="code" href="classcds_1_1container_1_1_segmented_queue.html#a19fd9b1e189ecfefb3fe7dbe8718c529">enqueue_with</a>( [&amp;bar]( Foo&amp; dest ) { dest = bar; } );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9bc20c03ee6b82b48f19e1b1a71e52a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcds_1_1container_1_1_segmented_queue.html#acbdb5f79369b42a242228cea23c7e510">stat</a>&amp; <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, T, Traits &gt;::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to internal statistics. </p>
<p>The type of internal statistics is specified by <code>Traits</code> template argument. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/segmented_queue.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:21 by Doxygen 1.8.8</i>
</div>
</body>
</html>
