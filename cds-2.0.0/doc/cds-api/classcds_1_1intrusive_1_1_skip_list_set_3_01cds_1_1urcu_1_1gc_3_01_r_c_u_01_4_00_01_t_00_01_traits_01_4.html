<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">SkipListSet< cds::urcu::gc< RCU >, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/skip_list_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.png" usemap="#cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" alt=""/>
  <map id="cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" name="cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html" title="Lock-free skip-list set (template specialization for RCU) " alt="cds::container::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;" shape="rect" coords="0,56,359,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae2e96fd2856b64d703d2a34ac96bd360"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2e96fd2856b64d703d2a34ac96bd360"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae2e96fd2856b64d703d2a34ac96bd360">gc</a></td></tr>
<tr class="memdesc:ae2e96fd2856b64d703d2a34ac96bd360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:ae2e96fd2856b64d703d2a34ac96bd360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87eb39e183716059cc1c726a7052bae9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87eb39e183716059cc1c726a7052bae9"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a></td></tr>
<tr class="memdesc:a87eb39e183716059cc1c726a7052bae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br /></td></tr>
<tr class="separator:a87eb39e183716059cc1c726a7052bae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae637d0767d1247a43e55d0c5dd076d8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae637d0767d1247a43e55d0c5dd076d8f"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae637d0767d1247a43e55d0c5dd076d8f">traits</a></td></tr>
<tr class="memdesc:ae637d0767d1247a43e55d0c5dd076d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:ae637d0767d1247a43e55d0c5dd076d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdfbe7825fdad7f2f17bc03a36783cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdfbe7825fdad7f2f17bc03a36783cb"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6cdfbe7825fdad7f2f17bc03a36783cb">hook</a></td></tr>
<tr class="memdesc:a6cdfbe7825fdad7f2f17bc03a36783cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a6cdfbe7825fdad7f2f17bc03a36783cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2023a2bbf1b6cb3c1930f20dcb6f0e4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2023a2bbf1b6cb3c1930f20dcb6f0e4f"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2023a2bbf1b6cb3c1930f20dcb6f0e4f">node_type</a></td></tr>
<tr class="memdesc:a2023a2bbf1b6cb3c1930f20dcb6f0e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a2023a2bbf1b6cb3c1930f20dcb6f0e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd2979690bf4022645175cfe0572111"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd2979690bf4022645175cfe0572111"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9dd2979690bf4022645175cfe0572111">key_comparator</a></td></tr>
<tr class="memdesc:a9dd2979690bf4022645175cfe0572111"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on <code>Traits::compare</code> and <code>Traits::less</code> <br /></td></tr>
<tr class="separator:a9dd2979690bf4022645175cfe0572111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7121095d7eac4eb4b933d8cb1593c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7121095d7eac4eb4b933d8cb1593c2"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3c7121095d7eac4eb4b933d8cb1593c2">disposer</a></td></tr>
<tr class="memdesc:a3c7121095d7eac4eb4b933d8cb1593c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer <br /></td></tr>
<tr class="separator:a3c7121095d7eac4eb4b933d8cb1593c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6901e8afe1eb0d98205ed9999a7c74b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6901e8afe1eb0d98205ed9999a7c74b"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2023a2bbf1b6cb3c1930f20dcb6f0e4f">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6cdfbe7825fdad7f2f17bc03a36783cb">hook</a> &gt;<br class="typebreak" />
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab6901e8afe1eb0d98205ed9999a7c74b">node_traits</a></td></tr>
<tr class="memdesc:ab6901e8afe1eb0d98205ed9999a7c74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:ab6901e8afe1eb0d98205ed9999a7c74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04985fdcd62123f916b04aa2d12d1f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04985fdcd62123f916b04aa2d12d1f9b"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a04985fdcd62123f916b04aa2d12d1f9b">item_counter</a></td></tr>
<tr class="memdesc:a04985fdcd62123f916b04aa2d12d1f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a04985fdcd62123f916b04aa2d12d1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96ff679ba35b3eac076e394ce8afb18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae96ff679ba35b3eac076e394ce8afb18"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae96ff679ba35b3eac076e394ce8afb18">memory_model</a></td></tr>
<tr class="memdesc:ae96ff679ba35b3eac076e394ce8afb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ae96ff679ba35b3eac076e394ce8afb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727c194feedfece897ea0a8c43334b97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727c194feedfece897ea0a8c43334b97"></a>
typedef <br class="typebreak" />
traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a727c194feedfece897ea0a8c43334b97">random_level_generator</a></td></tr>
<tr class="memdesc:a727c194feedfece897ea0a8c43334b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a727c194feedfece897ea0a8c43334b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2195348ae0f6e77dda69070ca9a6c3ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2195348ae0f6e77dda69070ca9a6c3ea"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2195348ae0f6e77dda69070ca9a6c3ea">allocator_type</a></td></tr>
<tr class="memdesc:a2195348ae0f6e77dda69070ca9a6c3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br /></td></tr>
<tr class="separator:a2195348ae0f6e77dda69070ca9a6c3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6718bca72647b89ba51bb2c2abefd3a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6718bca72647b89ba51bb2c2abefd3a5"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6718bca72647b89ba51bb2c2abefd3a5">back_off</a></td></tr>
<tr class="memdesc:a6718bca72647b89ba51bb2c2abefd3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a6718bca72647b89ba51bb2c2abefd3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad72fbde728c1d36705a8f3e4e5ac270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad72fbde728c1d36705a8f3e4e5ac270"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aad72fbde728c1d36705a8f3e4e5ac270">stat</a></td></tr>
<tr class="memdesc:aad72fbde728c1d36705a8f3e4e5ac270"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:aad72fbde728c1d36705a8f3e4e5ac270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83151d3c5e118839794e83fab5e4f72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac83151d3c5e118839794e83fab5e4f72"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac83151d3c5e118839794e83fab5e4f72">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:ac83151d3c5e118839794e83fab5e4f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:ac83151d3c5e118839794e83fab5e4f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a3a324eca1f701e227c2d8df6dd604"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a3a324eca1f701e227c2d8df6dd604"></a>
typedef gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af4a3a324eca1f701e227c2d8df6dd604">rcu_lock</a></td></tr>
<tr class="memdesc:af4a3a324eca1f701e227c2d8df6dd604"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:af4a3a324eca1f701e227c2d8df6dd604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154916824e4486e601d733e5dea6419a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a154916824e4486e601d733e5dea6419a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a> = <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae2e96fd2856b64d703d2a34ac96bd360">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>, node_disposer, void &gt;</td></tr>
<tr class="memdesc:a154916824e4486e601d733e5dea6419a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to extracted node <br /></td></tr>
<tr class="separator:a154916824e4486e601d733e5dea6419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb44322abdc57c532066f52995fd623a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb44322abdc57c532066f52995fd623a"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae2e96fd2856b64d703d2a34ac96bd360">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab6901e8afe1eb0d98205ed9999a7c74b">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6718bca72647b89ba51bb2c2abefd3a5">back_off</a>, <br class="typebreak" />
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a></td></tr>
<tr class="memdesc:abb44322abdc57c532066f52995fd623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br /></td></tr>
<tr class="separator:abb44322abdc57c532066f52995fd623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1247e2dec27d2973dff9e91d70c2d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1247e2dec27d2973dff9e91d70c2d3"></a>
typedef <br class="typebreak" />
skip_list::details::iterator<br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae2e96fd2856b64d703d2a34ac96bd360">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab6901e8afe1eb0d98205ed9999a7c74b">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6718bca72647b89ba51bb2c2abefd3a5">back_off</a>, <br class="typebreak" />
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a></td></tr>
<tr class="memdesc:aaf1247e2dec27d2973dff9e91d70c2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:aaf1247e2dec27d2973dff9e91d70c2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39394fe0ccee71e1adf2e66caf441316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39394fe0ccee71e1adf2e66caf441316"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a39394fe0ccee71e1adf2e66caf441316">SkipListSet</a> ()</td></tr>
<tr class="memdesc:a39394fe0ccee71e1adf2e66caf441316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a39394fe0ccee71e1adf2e66caf441316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d559cc0cf7177dba131192444823ad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d559cc0cf7177dba131192444823ad9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a4d559cc0cf7177dba131192444823ad9">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:a4d559cc0cf7177dba131192444823ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br /></td></tr>
<tr class="separator:a4d559cc0cf7177dba131192444823ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47b9cd482ca18a0b3800801ca6a2a0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa47b9cd482ca18a0b3800801ca6a2a0e"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aa47b9cd482ca18a0b3800801ca6a2a0e">begin</a> ()</td></tr>
<tr class="memdesc:aa47b9cd482ca18a0b3800801ca6a2a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:aa47b9cd482ca18a0b3800801ca6a2a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85810890aa68233484a9abb9c48e3f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85810890aa68233484a9abb9c48e3f2b"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a85810890aa68233484a9abb9c48e3f2b">begin</a> () const </td></tr>
<tr class="memdesc:a85810890aa68233484a9abb9c48e3f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a85810890aa68233484a9abb9c48e3f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7444e3d11ebe570a8ca559b739c580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace7444e3d11ebe570a8ca559b739c580"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ace7444e3d11ebe570a8ca559b739c580">cbegin</a> () const </td></tr>
<tr class="memdesc:ace7444e3d11ebe570a8ca559b739c580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ace7444e3d11ebe570a8ca559b739c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d5914f0539a90c706e8aefd621f33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f8d5914f0539a90c706e8aefd621f33"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6f8d5914f0539a90c706e8aefd621f33">end</a> ()</td></tr>
<tr class="memdesc:a6f8d5914f0539a90c706e8aefd621f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a6f8d5914f0539a90c706e8aefd621f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac38a1ddd25b0bd74d968d759e6dc340"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac38a1ddd25b0bd74d968d759e6dc340"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aac38a1ddd25b0bd74d968d759e6dc340">end</a> () const </td></tr>
<tr class="memdesc:aac38a1ddd25b0bd74d968d759e6dc340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:aac38a1ddd25b0bd74d968d759e6dc340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e65f6ccd741fa9145764640243cca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5e65f6ccd741fa9145764640243cca"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aef5e65f6ccd741fa9145764640243cca">cend</a> () const </td></tr>
<tr class="memdesc:aef5e65f6ccd741fa9145764640243cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:aef5e65f6ccd741fa9145764640243cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1163a54953b46022d34ab675dd1a7ae9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1163a54953b46022d34ab675dd1a7ae9">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a1163a54953b46022d34ab675dd1a7ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a1163a54953b46022d34ab675dd1a7ae9">More...</a><br /></td></tr>
<tr class="separator:a1163a54953b46022d34ab675dd1a7ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e449602a3c25565f0e76ac59b172b49"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a7e449602a3c25565f0e76ac59b172b49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7e449602a3c25565f0e76ac59b172b49">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a7e449602a3c25565f0e76ac59b172b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a7e449602a3c25565f0e76ac59b172b49">More...</a><br /></td></tr>
<tr class="separator:a7e449602a3c25565f0e76ac59b172b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7583530d6a731a5a77ecb641fa91b6a0"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a7583530d6a731a5a77ecb641fa91b6a0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7583530d6a731a5a77ecb641fa91b6a0">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a7583530d6a731a5a77ecb641fa91b6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#a7583530d6a731a5a77ecb641fa91b6a0">More...</a><br /></td></tr>
<tr class="separator:a7583530d6a731a5a77ecb641fa91b6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147b2eb75b2c1a083f61f50e42d35384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a147b2eb75b2c1a083f61f50e42d35384">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a147b2eb75b2c1a083f61f50e42d35384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#a147b2eb75b2c1a083f61f50e42d35384">More...</a><br /></td></tr>
<tr class="separator:a147b2eb75b2c1a083f61f50e42d35384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec5e2a6e4d638922062599b9bc2c972"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:acec5e2a6e4d638922062599b9bc2c972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#acec5e2a6e4d638922062599b9bc2c972">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:acec5e2a6e4d638922062599b9bc2c972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with specified <code>key</code>.  <a href="#acec5e2a6e4d638922062599b9bc2c972">More...</a><br /></td></tr>
<tr class="separator:acec5e2a6e4d638922062599b9bc2c972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b1011b91ab75523d467c4b6abb96f8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a89b1011b91ab75523d467c4b6abb96f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a89b1011b91ab75523d467c4b6abb96f8">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a89b1011b91ab75523d467c4b6abb96f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with comparing functor <code>pred</code>.  <a href="#a89b1011b91ab75523d467c4b6abb96f8">More...</a><br /></td></tr>
<tr class="separator:a89b1011b91ab75523d467c4b6abb96f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af121db55fe6d6263df0bb124f2ca8dd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af121db55fe6d6263df0bb124f2ca8dd4">extract_min</a> ()</td></tr>
<tr class="memdesc:af121db55fe6d6263df0bb124f2ca8dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the list.  <a href="#af121db55fe6d6263df0bb124f2ca8dd4">More...</a><br /></td></tr>
<tr class="separator:af121db55fe6d6263df0bb124f2ca8dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5de6793b2aedcd1f2c9a232956289d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aa5de6793b2aedcd1f2c9a232956289d6">extract_max</a> ()</td></tr>
<tr class="memdesc:aa5de6793b2aedcd1f2c9a232956289d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the list.  <a href="#aa5de6793b2aedcd1f2c9a232956289d6">More...</a><br /></td></tr>
<tr class="separator:aa5de6793b2aedcd1f2c9a232956289d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d299ed5f62bd994b6abe64a38d7b8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a748d299ed5f62bd994b6abe64a38d7b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a748d299ed5f62bd994b6abe64a38d7b8">erase</a> (const Q &amp;key)</td></tr>
<tr class="memdesc:a748d299ed5f62bd994b6abe64a38d7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a748d299ed5f62bd994b6abe64a38d7b8">More...</a><br /></td></tr>
<tr class="separator:a748d299ed5f62bd994b6abe64a38d7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555c316346134bb56b9459a398d87721"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a555c316346134bb56b9459a398d87721"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a555c316346134bb56b9459a398d87721">erase_with</a> (const Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a555c316346134bb56b9459a398d87721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set with comparing functor <code>pred</code>.  <a href="#a555c316346134bb56b9459a398d87721">More...</a><br /></td></tr>
<tr class="separator:a555c316346134bb56b9459a398d87721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad32a11bac9ebb7da30d01c46637dc7"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a3ad32a11bac9ebb7da30d01c46637dc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3ad32a11bac9ebb7da30d01c46637dc7">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a3ad32a11bac9ebb7da30d01c46637dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a3ad32a11bac9ebb7da30d01c46637dc7">More...</a><br /></td></tr>
<tr class="separator:a3ad32a11bac9ebb7da30d01c46637dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212bbe201e4230e902ec3ec41c345a79"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a212bbe201e4230e902ec3ec41c345a79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a212bbe201e4230e902ec3ec41c345a79">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a212bbe201e4230e902ec3ec41c345a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set with comparing functor <code>pred</code>.  <a href="#a212bbe201e4230e902ec3ec41c345a79">More...</a><br /></td></tr>
<tr class="separator:a212bbe201e4230e902ec3ec41c345a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b22396c7702dbac0f1f9fc806cf7f"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ab45b22396c7702dbac0f1f9fc806cf7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab45b22396c7702dbac0f1f9fc806cf7f">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:ab45b22396c7702dbac0f1f9fc806cf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="#ab45b22396c7702dbac0f1f9fc806cf7f">More...</a><br /></td></tr>
<tr class="separator:ab45b22396c7702dbac0f1f9fc806cf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850df90ea6b87dbf171805591b85f1a3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a850df90ea6b87dbf171805591b85f1a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a850df90ea6b87dbf171805591b85f1a3">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a850df90ea6b87dbf171805591b85f1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with comparing functor <code>pred</code>.  <a href="#a850df90ea6b87dbf171805591b85f1a3">More...</a><br /></td></tr>
<tr class="separator:a850df90ea6b87dbf171805591b85f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e62f2863e17a3ccbfda19f65ccb6407"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9e62f2863e17a3ccbfda19f65ccb6407"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9e62f2863e17a3ccbfda19f65ccb6407">find</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9e62f2863e17a3ccbfda19f65ccb6407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="#a9e62f2863e17a3ccbfda19f65ccb6407">More...</a><br /></td></tr>
<tr class="separator:a9e62f2863e17a3ccbfda19f65ccb6407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d831bafed08e62cdec2ade28a28ac6"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a12d831bafed08e62cdec2ade28a28ac6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a12d831bafed08e62cdec2ade28a28ac6">find_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a12d831bafed08e62cdec2ade28a28ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> with comparing functor <code>pred</code>.  <a href="#a12d831bafed08e62cdec2ade28a28ac6">More...</a><br /></td></tr>
<tr class="separator:a12d831bafed08e62cdec2ade28a28ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9ebdbd4e15eea65f92420fc703b56"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:af4c9ebdbd4e15eea65f92420fc703b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af4c9ebdbd4e15eea65f92420fc703b56">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:af4c9ebdbd4e15eea65f92420fc703b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#af4c9ebdbd4e15eea65f92420fc703b56">More...</a><br /></td></tr>
<tr class="separator:af4c9ebdbd4e15eea65f92420fc703b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb34a4a6c1a3f33f49cfee91f34e415"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2eb34a4a6c1a3f33f49cfee91f34e415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2eb34a4a6c1a3f33f49cfee91f34e415">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a2eb34a4a6c1a3f33f49cfee91f34e415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a2eb34a4a6c1a3f33f49cfee91f34e415">More...</a><br /></td></tr>
<tr class="separator:a2eb34a4a6c1a3f33f49cfee91f34e415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309bc3364338417818258cf3bb8e1955"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a309bc3364338417818258cf3bb8e1955">size</a> () const </td></tr>
<tr class="memdesc:a309bc3364338417818258cf3bb8e1955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a309bc3364338417818258cf3bb8e1955">More...</a><br /></td></tr>
<tr class="separator:a309bc3364338417818258cf3bb8e1955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc4c7fe695b74eb925e110fff8195f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc4c7fe695b74eb925e110fff8195f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7bc4c7fe695b74eb925e110fff8195f4">empty</a> () const </td></tr>
<tr class="memdesc:a7bc4c7fe695b74eb925e110fff8195f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br /></td></tr>
<tr class="separator:a7bc4c7fe695b74eb925e110fff8195f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6776d787ba35e4124e4c6da1d644191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac6776d787ba35e4124e4c6da1d644191">clear</a> ()</td></tr>
<tr class="memdesc:ac6776d787ba35e4124e4c6da1d644191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic)  <a href="#ac6776d787ba35e4124e4c6da1d644191">More...</a><br /></td></tr>
<tr class="separator:ac6776d787ba35e4124e4c6da1d644191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29d5319b494eb2e66b8f906c3012319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29d5319b494eb2e66b8f906c3012319"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aad72fbde728c1d36705a8f3e4e5ac270">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aa29d5319b494eb2e66b8f906c3012319">statistics</a> () const </td></tr>
<tr class="memdesc:aa29d5319b494eb2e66b8f906c3012319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:aa29d5319b494eb2e66b8f906c3012319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f13b1537c7d6a5afc4210b0c956beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab4f13b1537c7d6a5afc4210b0c956beb">force_dispose</a> ()</td></tr>
<tr class="memdesc:ab4f13b1537c7d6a5afc4210b0c956beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears internal list of ready-to-remove items passing it to RCU reclamation cycle.  <a href="#ab4f13b1537c7d6a5afc4210b0c956beb">More...</a><br /></td></tr>
<tr class="separator:ab4f13b1537c7d6a5afc4210b0c956beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af23acc4cbc1470a449a602257c6aae34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23acc4cbc1470a449a602257c6aae34"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af23acc4cbc1470a449a602257c6aae34">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:af23acc4cbc1470a449a602257c6aae34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br /></td></tr>
<tr class="separator:af23acc4cbc1470a449a602257c6aae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a25471f7de686639f6b79bae7a1025055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25471f7de686639f6b79bae7a1025055"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a25471f7de686639f6b79bae7a1025055">c_bExtractLockExternal</a> = false</td></tr>
<tr class="memdesc:a25471f7de686639f6b79bae7a1025055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions does not require external locking. <br /></td></tr>
<tr class="separator:a25471f7de686639f6b79bae7a1025055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad236306645f0cb67a173f516682eb9b5"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad236306645f0cb67a173f516682eb9b5">c_nMaxHeight</a></td></tr>
<tr class="memdesc:ad236306645f0cb67a173f516682eb9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="#ad236306645f0cb67a173f516682eb9b5">More...</a><br /></td></tr>
<tr class="separator:ad236306645f0cb67a173f516682eb9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a615835761c98da610cec5860ffa00d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a615835761c98da610cec5860ffa00d81"></a>
typedef <br class="typebreak" />
node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a615835761c98da610cec5860ffa00d81">atomic_node_ptr</a></td></tr>
<tr class="memdesc:a615835761c98da610cec5860ffa00d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked node pointer. <br /></td></tr>
<tr class="separator:a615835761c98da610cec5860ffa00d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950371c68483566ca2e121e0f98b86c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a950371c68483566ca2e121e0f98b86c6"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a950371c68483566ca2e121e0f98b86c6">marked_node_ptr</a></td></tr>
<tr class="memdesc:a950371c68483566ca2e121e0f98b86c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br /></td></tr>
<tr class="separator:a950371c68483566ca2e121e0f98b86c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afae8bfdf6c879d3037361a145c23ac7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae8bfdf6c879d3037361a145c23ac7e"></a>
skip_list::details::head_node<br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2023a2bbf1b6cb3c1930f20dcb6f0e4f">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#afae8bfdf6c879d3037361a145c23ac7e">m_Head</a></td></tr>
<tr class="memdesc:afae8bfdf6c879d3037361a145c23ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">head tower (max height) <br /></td></tr>
<tr class="separator:afae8bfdf6c879d3037361a145c23ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb781123cc1eab56376b02f55cad8af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb781123cc1eab56376b02f55cad8af"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a04985fdcd62123f916b04aa2d12d1f9b">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2fb781123cc1eab56376b02f55cad8af">m_ItemCounter</a></td></tr>
<tr class="memdesc:a2fb781123cc1eab56376b02f55cad8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a2fb781123cc1eab56376b02f55cad8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae49affca9dba616735dc9d6bbabb464"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae49affca9dba616735dc9d6bbabb464"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a727c194feedfece897ea0a8c43334b97">random_level_generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aae49affca9dba616735dc9d6bbabb464">m_RandomLevelGen</a></td></tr>
<tr class="memdesc:aae49affca9dba616735dc9d6bbabb464"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator instance <br /></td></tr>
<tr class="separator:aae49affca9dba616735dc9d6bbabb464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ecc782286a70cd9318cb55df957fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5ecc782286a70cd9318cb55df957fc6"></a>
atomics::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae5ecc782286a70cd9318cb55df957fc6">m_nHeight</a></td></tr>
<tr class="memdesc:ae5ecc782286a70cd9318cb55df957fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimated high level <br /></td></tr>
<tr class="separator:ae5ecc782286a70cd9318cb55df957fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4e1266cd571dde39103c9e2c22114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21f4e1266cd571dde39103c9e2c22114"></a>
atomics::atomic&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2023a2bbf1b6cb3c1930f20dcb6f0e4f">node_type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a21f4e1266cd571dde39103c9e2c22114">m_pDeferredDelChain</a></td></tr>
<tr class="memdesc:a21f4e1266cd571dde39103c9e2c22114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deferred deleted node chain. <br /></td></tr>
<tr class="separator:a21f4e1266cd571dde39103c9e2c22114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3963d2176aa962eb4743c4e39b7bde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d3963d2176aa962eb4743c4e39b7bde"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aad72fbde728c1d36705a8f3e4e5ac270">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0d3963d2176aa962eb4743c4e39b7bde">m_Stat</a></td></tr>
<tr class="memdesc:a0d3963d2176aa962eb4743c4e39b7bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:a0d3963d2176aa962eb4743c4e39b7bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename T, typename Traits = skip_list::traits&gt;<br />
class cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</h3>

<p>Lock-free skip-list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu"></a> The implementation of well-known probabilistic data structure called skip-list invented by W.Pugh in his papers:</p><ul>
<li>[1989] W.Pugh Skip Lists: A Probabilistic Alternative to Balanced Trees</li>
<li>[1990] W.Pugh A Skip List Cookbook</li>
</ul>
<p>A skip-list is a probabilistic data structure that provides expected logarithmic time search without the need of rebalance. The skip-list is a collection of sorted linked list. Nodes are ordered by key. Each node is linked into a subset of the lists. Each list has a level, ranging from 0 to 32. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each node is created with a random top level (with a random height), and belongs to all lists up to that level. The probability that a node has the height 1 is 1/2. The probability that a node has the height N is 1/2 ** N (more precisely, the distribution depends on an random generator provided, but our generators have this property).</p>
<p>The lock-free variant of skip-list is implemented according to book</p><ul>
<li>[2008] M.Herlihy, N.Shavit "The Art of Multiprocessor Programming", chapter 14.4 "A Lock-Free Concurrent Skiplist".</li>
</ul>
<p><b>Template arguments</b>:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>T</code> - type to be stored in the list. The type must be based on <code><a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node. ">skip_list::node</a></code> (for <code><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1base__hook.html" title="Base hook. ">skip_list::base_hook</a></code>) or it must have a member of type <code><a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node. ">skip_list::node</a></code> (for <code><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1member__hook.html" title="Member hook. ">skip_list::member_hook</a></code>).</li>
<li><code>Traits</code> - set traits, default is <code><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1traits.html" title="SkipListSet traits ">skip_list::traits</a></code> It is possible to declare option-based list with <code><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits. ">cds::intrusive::skip_list::make_traits</a></code> metafunction instead of <code>Traits</code> template argument.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/intrusive/skip_list_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files.</dd></dl>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a> and <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf1247e2dec27d2973dff9e91d70c2d3">const_iterator</a>). The iteration is ordered.</p>
<p>You may iterate over skip-list set items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any set's item cannot be reclaimed.</p>
<dl class="section note"><dt>Note</dt><dd>The requirement of RCU lock during iterating means that any type of modification of the skip list (i.e. inserting, erasing and so on) is not possible.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads.</dd></dl>
<p>Example how to use skip-list set iterators: </p><div class="fragment"><div class="line"><span class="comment">// First, you should include the header for RCU type you have chosen</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/skip_list_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt; rcu_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Traits for your skip-list.</span></div>
<div class="line"><span class="comment">// At least, you should define cds::opt::less or cds::opt::compare for Foo struct</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1traits.html">cds::intrusive::skip_list::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; rcu_type, Foo, my_traits &gt;</a> my_skiplist_set;</div>
<div class="line"></div>
<div class="line">my_skiplist_set theSet;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Begin iteration</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Apply RCU locking manually</span></div>
<div class="line">    <span class="keyword">typename</span> rcu_type::scoped_lock sl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keyword">auto</span> it = theList.begin(); it != theList.end(); ++it ) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// rcu_type::scoped_lock destructor releases RCU lock implicitly</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a> <span class="keyword">const</span>&amp; s);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>&amp; operator ++();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a>&amp; src);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abb44322abdc57c532066f52995fd623a">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6f8d5914f0539a90c706e8aefd621f33">end</a>, <code>cend</code> member functions points to <code>nullptr</code> and should not be dereferenced.</p>
<p><b>How to use</b></p>
<p>You should incorporate <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node. ">skip_list::node</a> into your struct <code>T</code> and provide appropriate <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1traits.html#aeabd2876dac1fa7dddb475b175728dfa" title="Hook used. ">skip_list::traits::hook</a> in your <code>Traits</code> template parameters. Usually, for <code>Traits</code> you define a struct based on <code><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1traits.html" title="SkipListSet traits ">skip_list::traits</a></code>.</p>
<p>Example for <code>cds::urcu::general_buffered&lt;&gt;</code> RCU and base hook: </p><div class="fragment"><div class="line"><span class="comment">// First, you should include the header for RCU type you have chosen</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Include RCU skip-list specialization</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/skip_list_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// RCU type typedef</span></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt; rcu_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Data stored in skip list</span></div>
<div class="line"><span class="keyword">struct </span>my_data: <span class="keyword">public</span> <a class="code" href="classcds_1_1intrusive_1_1skip__list_1_1node.html">cds::intrusive::skip_list::node</a>&lt; rcu_type &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key field</span></div>
<div class="line">    std::string     strKey;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// other data</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// my_data compare functor</span></div>
<div class="line"><span class="keyword">struct </span>my_data_cmp {</div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare traits</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1traits.html">cds::intrusive::skip_list::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1base__hook.html">cds::intrusive::skip_list::base_hook&lt; cds::opt::gc&lt; rcu_type &gt;</a> &gt;   <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6cdfbe7825fdad7f2f17bc03a36783cb">hook</a>;</div>
<div class="line">    <span class="keyword">typedef</span> my_data_cmp compare;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare skip-list set type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; rcu_type, my_data, my_traits &gt;</a>     traits_based_set;</div>
</div><!-- fragment --><p>Equivalent option-based code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/skip_list_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt; rcu_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_data {</div>
<div class="line">    <span class="comment">// see above</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>compare {</div>
<div class="line">    <span class="comment">// see above</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare option-based skip-list set</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; rcu_type</div>
<div class="line">    ,my_data</div>
<div class="line">    , <span class="keyword">typename</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1make__traits.html">cds::intrusive::skip_list::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1intrusive_1_1opt_1_1hook.html">cds::intrusive::opt::hook&lt; cds::intrusive::skip_list::base_hook&lt; cds::opt::gc&lt; rcu_type &gt;</a> &gt; &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1compare.html">cds::intrusive::opt::compare&lt; my_data_cmp &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; option_based_set;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac6776d787ba35e4124e4c6da1d644191"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (not atomic) </p>
<p>The function unlink all items from the set. The function is not atomic, thus, in multi-threaded environment with parallel insertions this sequence </p><div class="fragment"><div class="line">set.clear();</div>
<div class="line">assert( set.empty() );</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each item the <code>disposer</code> will be called automatically after unlinking. </p>

</div>
</div>
<a class="anchor" id="a7583530d6a731a5a77ecb641fa91b6a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>val</code> exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the set, then <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with item found. The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code>() function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refer to the same thing.</li>
</ul>
<p>The functor can change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a748d299ed5f62bd994b6abe64a38d7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_erase"></a>The function searches an item with key equal to <code>key</code> in the set, unlinks it from the set, and returns <code>true</code>. If the item with key equal to <code>key</code> is not found the function return <code>false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a3ad32a11bac9ebb7da30d01c46637dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_erase_func"></a>The function searches an item with key equal to <code>key</code> in the set, call <code>f</code> functor with item found, unlinks it from the set, and returns <code>true</code>. The <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3c7121095d7eac4eb4b933d8cb1593c2">disposer</a> specified in <code>Traits</code> class template parameter is called by garbage collector <code>GC</code> asynchronously.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> <span class="keyword">const</span>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the item with key equal to <code>key</code> is not found the function return <code>false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a555c316346134bb56b9459a398d87721"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the item from the set with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_erase">erase(Q const&amp;)</a> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a212bbe201e4230e902ec3ec41c345a79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the item from the set with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="acec5e2a6e4d638922062599b9bc2c972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the set with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the set, unlinks it from the set, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item with key equal to <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. Example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt;</a> &gt;, foo, my_traits &gt; skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> skip_list::exempt_ptr ep( theList.extract( 5 ));</div>
<div class="line"><span class="keywordflow">if</span> ( ep ) {</div>
<div class="line">    <span class="comment">// Deal with ep</span></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Dispose returned item.</span></div>
<div class="line">    ep.release();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa5de6793b2aedcd1f2c9a232956289d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the list. </p>
<p>The function searches an item with maximal key, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item. If the skip-list is empty the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is manually called. Example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;, foo, my_traits &gt; skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> skip_list::exempt_ptr ep( theList.extract_max() );</div>
<div class="line"><span class="keywordflow">if</span> ( ep ) {</div>
<div class="line">    <span class="comment">// Deal with ep</span></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <span class="comment">// Dispose returned item.</span></div>
<div class="line">    ep.release();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the list, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost item and tries to unlink it. During unlinking, a concurrent thread can insert an item with key greater than rightmost item's key. So, the function returns the item with maximum key at the moment of list traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="af121db55fe6d6263df0bb124f2ca8dd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the list. </p>
<p>The function searches an item with minimal key, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item. If the skip-list is empty the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is manually called. Example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;, foo, my_traits &gt; skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> skip_list::exempt_ptr ep(theList.extract_min());</div>
<div class="line"><span class="keywordflow">if</span> ( ep ) {</div>
<div class="line">    <span class="comment">// Deal with ep</span></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Dispose returned item.</span></div>
<div class="line">    ep.release();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the list, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost item and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of list traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="a89b1011b91ab75523d467c4b6abb96f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a154916824e4486e601d733e5dea6419a">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the set with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_extract">extract(exempt_ptr&amp;, Q const&amp;)</a> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ab45b22396c7702dbac0f1f9fc806cf7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_find_func"></a>The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>&amp; item, Q&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>key</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a9e62f2863e17a3ccbfda19f65ccb6407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_find_val"></a>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a850df90ea6b87dbf171805591b85f1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_find_func">find(Q&amp;, Func)</a> but <code>cmp</code> is used for key comparison. <code>Less</code> functor has the interface like <code>std::less</code>. <code>cmp</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a12d831bafed08e62cdec2ade28a28ac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key compare. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ab4f13b1537c7d6a5afc4210b0c956beb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::force_dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears internal list of ready-to-remove items passing it to RCU reclamation cycle. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_force_dispose"></a>Skip list has complex multi-step algorithm for removing an item. In fact, when you remove the item it is just marked as removed that is enough for the success of your operation. Actual removing can take place in the future, in another call or even in another thread. Inside RCU lock the removed item cannot be passed to RCU reclamation cycle since it can lead to deadlock. To solve this problem, the current skip list implementation has internal list of items which is ready to remove but is not yet passed to RCU reclamation. Usually, this list will be passed to RCU reclamation in the next suitable call of skip list member function. In some cases we want to pass it to RCU reclamation immediately after RCU unlocking. This function provides such opportunity: it checks whether the RCU is not locked and if it is true the function passes the internal ready-to-remove list to RCU reclamation cycle.</p>
<p>The RCU <code>synchronize</code> can be called. </p>

</div>
</div>
<a class="anchor" id="af4c9ebdbd4e15eea65f92420fc703b56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>* <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns the pointer to item found. If <code>key</code> is not found it returns <code>nullptr</code>.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU should be locked before call of this function. Returned item is valid only while RCU is locked: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;, foo, my_traits &gt; skip_list;</div>
<div class="line">skip_list theList;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lock RCU</span></div>
<div class="line">    skip_list::rcu_lock lock;</div>
<div class="line"></div>
<div class="line">    foo * pVal = theList.get( 5 );</div>
<div class="line">    <span class="keywordflow">if</span> ( pVal ) {</div>
<div class="line">        <span class="comment">// Deal with pVal</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Unlock RCU by rcu_lock destructor</span></div>
<div class="line"><span class="comment">// pVal can be retired by disposer at any time after RCU has been unlocked</span></div>
</div><!-- fragment --><p>After RCU unlocking the <code>force_dispose</code> member function can be called manually, see <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab4f13b1537c7d6a5afc4210b0c956beb">force_dispose</a> for explanation. </p>

</div>
</div>
<a class="anchor" id="a2eb34a4a6c1a3f33f49cfee91f34e415"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>* <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_rcu_get">get(Q const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a1163a54953b46022d34ab675dd1a7ae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with key equal to <code>val</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a7e449602a3c25565f0e76ac59b172b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>This function is intended for derived non-intrusive containers.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a309bc3364338417818258cf3bb8e1955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. For <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> the function always returns 0. Therefore, the function is not suitable for checking the set emptiness, use <code><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7bc4c7fe695b74eb925e110fff8195f4" title="Checks if the set is empty. ">empty()</a></code> member function for this purpose. </p>

</div>
</div>
<a class="anchor" id="a147b2eb75b2c1a083f61f50e42d35384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87eb39e183716059cc1c726a7052bae9">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the item <code>val</code> from the set. </p>
<p>The function searches the item <code>val</code> in the set and unlink it from the set if it is found and is equal to <code>val</code>.</p>
<p>Difference between <code><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a748d299ed5f62bd994b6abe64a38d7b8" title="Deletes the item from the set. ">erase()</a></code> and <code>unlink</code>() functions: <code><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a748d299ed5f62bd994b6abe64a38d7b8" title="Deletes the item from the set. ">erase()</a></code> finds <em>a key</em> and deletes the item found. <code>unlink</code>() searches an item by key and deletes it only if <code>val</code> is an item of that set, i.e. the pointer to item found is equal to <code> &amp;val </code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>The <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3c7121095d7eac4eb4b933d8cb1593c2">disposer</a> specified in <code>Traits</code> class template parameter is called by garbage collector <code>GC</code> asynchronously.</p>
<p>The function returns <code>true</code> if success and <code>false</code> otherwise. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="ad236306645f0cb67a173f516682eb9b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int const <a class="el" href="singletoncds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::c_nMaxHeight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::conditional&lt;</div>
<div class="line">            (random_level_generator::c_nUpperBound &lt;= <a class="code" href="namespacecds_1_1intrusive_1_1skip__list.html#ada3b652d0f9a65b38dcd7697cb06c9e6">skip_list::c_nHeightLimit</a>),</div>
<div class="line">            std::integral_constant&lt; unsigned int, random_level_generator::c_nUpperBound &gt;,</div>
<div class="line">            std::integral_constant&lt; unsigned int, skip_list::c_nHeightLimit &gt;</div>
<div class="line">        &gt;::type::value</div>
</div><!-- fragment -->
<p>Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code> </p>
<p>The max height is specified by <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1random__level__generator.html">random level generator</a> constant <code>m_nUpperBound</code> but it should be no more than 32 (<a class="el" href="namespacecds_1_1intrusive_1_1skip__list.html#ada3b652d0f9a65b38dcd7697cb06c9e6">skip_list::c_nHeightLimit</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/skip_list_rcu.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:25 by Doxygen 1.8.8</i>
</div>
</body>
</html>
