<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">SegmentedQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__queue.html">Queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Segmented queue.  
 <a href="classcds_1_1intrusive_1_1_segmented_queue.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/segmented_queue.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_segmented_queue.png" usemap="#cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;_map" alt=""/>
  <map id="cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;_map" name="cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_segmented_queue.html" title="Segmented queue. " alt="cds::container::SegmentedQueue&lt; GC, T, Traits &gt;" shape="rect" coords="0,56,295,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a018256bb2afa8f6275854a7dba3ec55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018256bb2afa8f6275854a7dba3ec55d"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a018256bb2afa8f6275854a7dba3ec55d">gc</a></td></tr>
<tr class="memdesc:a018256bb2afa8f6275854a7dba3ec55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a018256bb2afa8f6275854a7dba3ec55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68ad757bbb48525397c39299565fde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada68ad757bbb48525397c39299565fde"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a></td></tr>
<tr class="memdesc:ada68ad757bbb48525397c39299565fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the value stored in the queue <br /></td></tr>
<tr class="separator:ada68ad757bbb48525397c39299565fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f505d4d990d1b4401c59ac9cd50c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5f505d4d990d1b4401c59ac9cd50c6"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a8b5f505d4d990d1b4401c59ac9cd50c6">traits</a></td></tr>
<tr class="memdesc:a8b5f505d4d990d1b4401c59ac9cd50c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue traits. <br /></td></tr>
<tr class="separator:a8b5f505d4d990d1b4401c59ac9cd50c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf619d38702a8a4cd635acbb800f0d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf619d38702a8a4cd635acbb800f0d05"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#abf619d38702a8a4cd635acbb800f0d05">disposer</a></td></tr>
<tr class="memdesc:abf619d38702a8a4cd635acbb800f0d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">value disposer, called only in <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#afee9d88ec841e1d0be906e663bd42583" title="Clear the queue. ">clear()</a></code> when the element to be dequeued <br /></td></tr>
<tr class="separator:abf619d38702a8a4cd635acbb800f0d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6a573283848be605468a47ee0cf42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae6a573283848be605468a47ee0cf42"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a7ae6a573283848be605468a47ee0cf42">allocator</a></td></tr>
<tr class="memdesc:a7ae6a573283848be605468a47ee0cf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator maintaining the segments. <br /></td></tr>
<tr class="separator:a7ae6a573283848be605468a47ee0cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5614453d4f178ad7c049f04f225d298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5614453d4f178ad7c049f04f225d298"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac5614453d4f178ad7c049f04f225d298">memory_model</a></td></tr>
<tr class="memdesc:ac5614453d4f178ad7c049f04f225d298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:ac5614453d4f178ad7c049f04f225d298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335dcf76c72477d0465dbbfd07b3225f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a335dcf76c72477d0465dbbfd07b3225f"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a335dcf76c72477d0465dbbfd07b3225f">item_counter</a></td></tr>
<tr class="memdesc:a335dcf76c72477d0465dbbfd07b3225f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy, see <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">cds::opt::item_counter</a> option setter. <br /></td></tr>
<tr class="separator:a335dcf76c72477d0465dbbfd07b3225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471a3dee01e363dccef7a35586ad55c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471a3dee01e363dccef7a35586ad55c2"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a></td></tr>
<tr class="memdesc:a471a3dee01e363dccef7a35586ad55c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy. <br /></td></tr>
<tr class="separator:a471a3dee01e363dccef7a35586ad55c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e33760ff11827c436068b657f039afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e33760ff11827c436068b657f039afd"></a>
typedef traits::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a2e33760ff11827c436068b657f039afd">lock_type</a></td></tr>
<tr class="memdesc:a2e33760ff11827c436068b657f039afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of mutex for maintaining an internal list of allocated segments. <br /></td></tr>
<tr class="separator:a2e33760ff11827c436068b657f039afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80618173d005e2059850b16f36a60098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80618173d005e2059850b16f36a60098"></a>
typedef <br class="typebreak" />
traits::permutation_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a80618173d005e2059850b16f36a60098">permutation_generator</a></td></tr>
<tr class="memdesc:a80618173d005e2059850b16f36a60098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random permutation generator for sequence [0, quasi-factor) <br /></td></tr>
<tr class="separator:a80618173d005e2059850b16f36a60098"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c4fd1d98114ea90334a750cd129c98d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a7c4fd1d98114ea90334a750cd129c98d">SegmentedQueue</a> (size_t nQuasiFactor)</td></tr>
<tr class="memdesc:a7c4fd1d98114ea90334a750cd129c98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the empty queue.  <a href="#a7c4fd1d98114ea90334a750cd129c98d">More...</a><br /></td></tr>
<tr class="separator:a7c4fd1d98114ea90334a750cd129c98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b05b53ee11731d9f54e8bd2b9c09e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363b05b53ee11731d9f54e8bd2b9c09e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a363b05b53ee11731d9f54e8bd2b9c09e">~SegmentedQueue</a> ()</td></tr>
<tr class="memdesc:a363b05b53ee11731d9f54e8bd2b9c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue and deletes all internal data. <br /></td></tr>
<tr class="separator:a363b05b53ee11731d9f54e8bd2b9c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23898b0b773dfefbcb618a889347c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23898b0b773dfefbcb618a889347c3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac23898b0b773dfefbcb618a889347c3d">enqueue</a> (<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac23898b0b773dfefbcb618a889347c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at last segment of the queue. <br /></td></tr>
<tr class="separator:ac23898b0b773dfefbcb618a889347c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527ba06eafde4f54bfa6e855f1fba46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46">dequeue</a> ()</td></tr>
<tr class="memdesc:af527ba06eafde4f54bfa6e855f1fba46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from first segment of the queue and returns it.  <a href="#af527ba06eafde4f54bfa6e855f1fba46">More...</a><br /></td></tr>
<tr class="separator:af527ba06eafde4f54bfa6e855f1fba46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f1f6d2ceab34776516aff23732e8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac64f1f6d2ceab34776516aff23732e8f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac64f1f6d2ceab34776516aff23732e8f">push</a> (<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac64f1f6d2ceab34776516aff23732e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ac23898b0b773dfefbcb618a889347c3d" title="Inserts a new element at last segment of the queue. ">enqueue(value_type&amp;)</a></code> member function. <br /></td></tr>
<tr class="separator:ac64f1f6d2ceab34776516aff23732e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85272b6a439ee0942b5e9520b98d1d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85272b6a439ee0942b5e9520b98d1d13"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a85272b6a439ee0942b5e9520b98d1d13">pop</a> ()</td></tr>
<tr class="memdesc:a85272b6a439ee0942b5e9520b98d1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46" title="Removes an element from first segment of the queue and returns it. ">dequeue()</a></code> member function. <br /></td></tr>
<tr class="separator:a85272b6a439ee0942b5e9520b98d1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c4870334e4bd33547cde391df7de15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a71c4870334e4bd33547cde391df7de15">empty</a> () const </td></tr>
<tr class="memdesc:a71c4870334e4bd33547cde391df7de15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="#a71c4870334e4bd33547cde391df7de15">More...</a><br /></td></tr>
<tr class="separator:a71c4870334e4bd33547cde391df7de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9d88ec841e1d0be906e663bd42583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#afee9d88ec841e1d0be906e663bd42583">clear</a> ()</td></tr>
<tr class="memdesc:afee9d88ec841e1d0be906e663bd42583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#afee9d88ec841e1d0be906e663bd42583">More...</a><br /></td></tr>
<tr class="separator:afee9d88ec841e1d0be906e663bd42583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9175386dac61a025d6b60f5d7a80ef"><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr class="memitem:a1c9175386dac61a025d6b60f5d7a80ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a1c9175386dac61a025d6b60f5d7a80ef">clear_with</a> (Disposer)</td></tr>
<tr class="memdesc:a1c9175386dac61a025d6b60f5d7a80ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a1c9175386dac61a025d6b60f5d7a80ef">More...</a><br /></td></tr>
<tr class="separator:a1c9175386dac61a025d6b60f5d7a80ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c763ebbcc9fc3edb148a282d2e83ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c763ebbcc9fc3edb148a282d2e83ea"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a13c763ebbcc9fc3edb148a282d2e83ea">size</a> () const </td></tr>
<tr class="memdesc:a13c763ebbcc9fc3edb148a282d2e83ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count. <br /></td></tr>
<tr class="separator:a13c763ebbcc9fc3edb148a282d2e83ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441f996643963423cf8a9ad041c8faf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a441f996643963423cf8a9ad041c8faf6">statistics</a> () const </td></tr>
<tr class="memdesc:a441f996643963423cf8a9ad041c8faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics.  <a href="#a441f996643963423cf8a9ad041c8faf6">More...</a><br /></td></tr>
<tr class="separator:a441f996643963423cf8a9ad041c8faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b503d61f87be1f83642d1cb5edbe57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b503d61f87be1f83642d1cb5edbe57"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a86b503d61f87be1f83642d1cb5edbe57">quasi_factor</a> () const </td></tr>
<tr class="memdesc:a86b503d61f87be1f83642d1cb5edbe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quasi factor, a power-of-two number. <br /></td></tr>
<tr class="separator:a86b503d61f87be1f83642d1cb5edbe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a47b4fc8634e24dc94bb733cde8694c0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b4fc8634e24dc94bb733cde8694c0d"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a47b4fc8634e24dc94bb733cde8694c0d">m_nHazardPtrCount</a> = 2</td></tr>
<tr class="memdesc:a47b4fc8634e24dc94bb733cde8694c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a47b4fc8634e24dc94bb733cde8694c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4e578806b102817a766e8df7d6ff4d74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e578806b102817a766e8df7d6ff4d74"></a>
segment_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a4e578806b102817a766e8df7d6ff4d74">m_SegmentList</a></td></tr>
<tr class="memdesc:a4e578806b102817a766e8df7d6ff4d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of segments. <br /></td></tr>
<tr class="separator:a4e578806b102817a766e8df7d6ff4d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6368e394b9f4c33600d204b1cd51603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6368e394b9f4c33600d204b1cd51603"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a335dcf76c72477d0465dbbfd07b3225f">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ab6368e394b9f4c33600d204b1cd51603">m_ItemCounter</a></td></tr>
<tr class="memdesc:ab6368e394b9f4c33600d204b1cd51603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:ab6368e394b9f4c33600d204b1cd51603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc7f8f9864de6707492b79a877ca970"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc7f8f9864de6707492b79a877ca970"></a>
<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a5bc7f8f9864de6707492b79a877ca970">m_Stat</a></td></tr>
<tr class="memdesc:a5bc7f8f9864de6707492b79a877ca970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a5bc7f8f9864de6707492b79a877ca970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename T, typename Traits = segmented_queue::traits&gt;<br />
class cds::intrusive::SegmentedQueue&lt; GC, T, Traits &gt;</h3>

<p>Segmented queue. </p>
<p>The queue is based on work</p><ul>
<li>[2010] Afek, Korland, Yanovsky "Quasi-Linearizability: relaxed consistency for improved concurrency"</li>
</ul>
<p>In this paper the authors offer a relaxed version of linearizability, so-called quasi-linearizability, that preserves some of the intuition, provides a flexible way to control the level of relaxation and supports th implementation of more concurrent and scalable data structure. Intuitively, the linearizability requires each run to be equivalent in some sense to a serial run of the algorithm. This equivalence to some serial run imposes strong synchronization requirements that in many cases results in limited scalability and synchronization bottleneck.</p>
<p>The general idea is that the queue maintains a linked list of segments, each segment is an array of nodes in the size of the quasi factor, and each node has a deleted boolean marker, which states if it has been dequeued. Each producer iterates over last segment in the linked list in some random permutation order. Whet it finds an empty cell it performs a CAS operation attempting to enqueue its new element. In case the entire segment has been scanned and no available cell is found (implying that the segment is full), then it attempts to add a new segment to the list.</p>
<p>The dequeue operation is similar: the consumer iterates over the first segment in the linked list in some random permutation order. When it finds an item which has not yet been dequeued, it performs CAS on its deleted marker in order to "delete" it, if succeeded this item is considered dequeued. In case the entire segment was scanned and all the nodes have already been dequeued (implying that the segment is empty), then it attempts to remove this segment from the linked list and starts the same process on the next segment. If there is no next segment, the queue is considered empty.</p>
<p>Based on the fact that most of the time threads do not add or remove segments, most of the work is done in parallel on different cells in the segments. This ensures a controlled contention depending on the segment size, which is quasi factor.</p>
<p>The segmented queue is an <em>unfair</em> queue since it violates the strong FIFO order but no more than quasi factor. This means that the consumer dequeues <em>any</em> item from the current first segment.</p>
<p>Template parameters:</p><ul>
<li><code>GC</code> - a garbage collector, possible types are <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">cds::gc::DHP</a></li>
<li><code>T</code> - the type of values stored in the queue</li>
<li><code>Traits</code> - queue type traits, default is <code><a class="el" href="structcds_1_1intrusive_1_1segmented__queue_1_1traits.html" title="SegmentedQueue default traits. ">segmented_queue::traits</a></code>. <code><a class="el" href="structcds_1_1intrusive_1_1segmented__queue_1_1make__traits.html" title="Metafunction converting option list to traits for SegmentedQueue. ">segmented_queue::make_traits</a></code> metafunction can be used to construct the type traits.</li>
</ul>
<p>The queue stores the pointers to enqueued items so no special node hooks are needed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c4fd1d98114ea90334a750cd129c98d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">SegmentedQueue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nQuasiFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the empty queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nQuasiFactor</td><td>Quasi factor. If it is not a power of 2 it is rounded up to nearest power of 2. Minimum is 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afee9d88ec841e1d0be906e663bd42583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>The function repeatedly calls <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46">dequeue</a> until it returns <code>nullptr</code>. The disposer specified in <code>Traits</code> template argument is called for each removed item. </p>

</div>
</div>
<a class="anchor" id="a1c9175386dac61a025d6b60f5d7a80ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::clear_with </td>
          <td>(</td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>The function repeatedly calls <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#af527ba06eafde4f54bfa6e855f1fba46" title="Removes an element from first segment of the queue and returns it. ">dequeue()</a></code> until it returns <code>nullptr</code>. <code>Disposer</code> is called for each removed item. </p>

</div>
</div>
<a class="anchor" id="af527ba06eafde4f54bfa6e855f1fba46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#ada68ad757bbb48525397c39299565fde">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::dequeue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from first segment of the queue and returns it. </p>
<p>If the queue is empty the function returns <code>nullptr</code>.</p>
<p>The disposer specified in <code>Traits</code> template argument is <b>not</b> called for returned item. You should manually dispose the item: <code> struct my_disposer { void operator()( foo * p ) { delete p; } }; cds::intrusive::SegmentedQueue&lt; cds::gc::HP, foo &gt; theQueue; ...</code></p>
<p><code>Dequeue an item foo * pItem = theQueue.dequeue(); deal with pItem ...</code></p>
<p><code>pItem is not longer needed and can be deleted Do it via <a class="el" href="classcds_1_1gc_1_1_h_p.html#a856385cf157f3e4ff17173b8e3d4ca2a" title="Retire pointer p with function pFunc. ">gc::HP::retire</a> cds::gc::HP::template retire&lt; my_disposer &gt;( pItem ); </code> </p>

</div>
</div>
<a class="anchor" id="a71c4870334e4bd33547cde391df7de15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the queue is empty. </p>
<p>The original segmented queue algorithm does not allow to check emptiness accurately because <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a71c4870334e4bd33547cde391df7de15" title="Checks if the queue is empty. ">empty()</a></code> is unlinearizable. This function tests queue's emptiness checking <code><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a13c763ebbcc9fc3edb148a282d2e83ea" title="Returns queue&#39;s item count. ">size()</a> == 0</code>, so, the item counting feature is an essential part of queue's algorithm. </p>

</div>
</div>
<a class="anchor" id="a441f996643963423cf8a9ad041c8faf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , typename Traits  = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html#a471a3dee01e363dccef7a35586ad55c2">stat</a>&amp; <a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">cds::intrusive::SegmentedQueue</a>&lt; GC, T, Traits &gt;::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to internal statistics. </p>
<p>The type of internal statistics is specified by <code>Traits</code> template argument. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/segmented_queue.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:25 by Doxygen 1.8.8</i>
</div>
</body>
</html>
