<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::intrusive::SplitListSet&lt; cds::gc::nogc, OrderedList, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html">SplitListSet< cds::gc::nogc, OrderedList, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::SplitListSet&lt; cds::gc::nogc, OrderedList, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>)  
 <a href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/split_list_nogc.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9928ee5b11afaf351a14d26fc268b31d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9928ee5b11afaf351a14d26fc268b31d"></a>
typedef <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a9928ee5b11afaf351a14d26fc268b31d">gc</a></td></tr>
<tr class="memdesc:a9928ee5b11afaf351a14d26fc268b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a9928ee5b11afaf351a14d26fc268b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c9aef18479eb5908521acb3ec57f0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c9aef18479eb5908521acb3ec57f0b"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#ab7c9aef18479eb5908521acb3ec57f0b">traits</a></td></tr>
<tr class="memdesc:ab7c9aef18479eb5908521acb3ec57f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameters. <br /></td></tr>
<tr class="separator:ab7c9aef18479eb5908521acb3ec57f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c36012baece0fe49f32c9749531298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40c36012baece0fe49f32c9749531298"></a>
typedef <br class="typebreak" />
cds::opt::v::hash_selector<br class="typebreak" />
&lt; typename traits::hash &gt;<br class="typebreak" />
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a40c36012baece0fe49f32c9749531298">hash</a></td></tr>
<tr class="memdesc:a40c36012baece0fe49f32c9749531298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:a40c36012baece0fe49f32c9749531298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d409c2cab46fd69bdf29e755afdc87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92d409c2cab46fd69bdf29e755afdc87"></a>
typedef OrderedList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a92d409c2cab46fd69bdf29e755afdc87">ordered_list</a></td></tr>
<tr class="memdesc:a92d409c2cab46fd69bdf29e755afdc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as base for split-list <br /></td></tr>
<tr class="separator:a92d409c2cab46fd69bdf29e755afdc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a7d35b2bde69ae53efe9d60eae2ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b5a7d35b2bde69ae53efe9d60eae2ad"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a></td></tr>
<tr class="memdesc:a5b5a7d35b2bde69ae53efe9d60eae2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the split-list <br /></td></tr>
<tr class="separator:a5b5a7d35b2bde69ae53efe9d60eae2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5705a4b0d8943693c1be59207c1e18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5705a4b0d8943693c1be59207c1e18"></a>
typedef <br class="typebreak" />
ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a0b5705a4b0d8943693c1be59207c1e18">key_comparator</a></td></tr>
<tr class="memdesc:a0b5705a4b0d8943693c1be59207c1e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a0b5705a4b0d8943693c1be59207c1e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329dcae87d5c43239fdb35335433da12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a329dcae87d5c43239fdb35335433da12"></a>
typedef ordered_list::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a329dcae87d5c43239fdb35335433da12">disposer</a></td></tr>
<tr class="memdesc:a329dcae87d5c43239fdb35335433da12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node disposer functor. <br /></td></tr>
<tr class="separator:a329dcae87d5c43239fdb35335433da12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35602b967de54f9536daa48223abcd3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35602b967de54f9536daa48223abcd3f"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a35602b967de54f9536daa48223abcd3f">item_counter</a></td></tr>
<tr class="memdesc:a35602b967de54f9536daa48223abcd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a35602b967de54f9536daa48223abcd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2315f13a367d3d800e752e4a5921958a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2315f13a367d3d800e752e4a5921958a"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a2315f13a367d3d800e752e4a5921958a">back_off</a></td></tr>
<tr class="memdesc:a2315f13a367d3d800e752e4a5921958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br /></td></tr>
<tr class="separator:a2315f13a367d3d800e752e4a5921958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693fe88fd443ca436c43ff8bc7ea3076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a693fe88fd443ca436c43ff8bc7ea3076"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a693fe88fd443ca436c43ff8bc7ea3076">memory_model</a></td></tr>
<tr class="memdesc:a693fe88fd443ca436c43ff8bc7ea3076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:a693fe88fd443ca436c43ff8bc7ea3076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2c74efd0b5c534a68b68e89d293dfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2c74efd0b5c534a68b68e89d293dfe"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a8b2c74efd0b5c534a68b68e89d293dfe">stat</a></td></tr>
<tr class="memdesc:a8b2c74efd0b5c534a68b68e89d293dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics, see <code>spit_list::stat</code>. <br /></td></tr>
<tr class="separator:a8b2c74efd0b5c534a68b68e89d293dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2a57152625dffb29657e9883f9de3c"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a></td></tr>
<tr class="memdesc:acc2a57152625dffb29657e9883f9de3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#acc2a57152625dffb29657e9883f9de3c">More...</a><br /></td></tr>
<tr class="separator:acc2a57152625dffb29657e9883f9de3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0bc5eb6da6e6687e1c07aa20015322"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a></td></tr>
<tr class="memdesc:a6c0bc5eb6da6e6687e1c07aa20015322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="#a6c0bc5eb6da6e6687e1c07aa20015322">More...</a><br /></td></tr>
<tr class="separator:a6c0bc5eb6da6e6687e1c07aa20015322"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf6bdc0cd48750d587607d481299a354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#aaf6bdc0cd48750d587607d481299a354">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aaf6bdc0cd48750d587607d481299a354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list of default capacity.  <a href="#aaf6bdc0cd48750d587607d481299a354">More...</a><br /></td></tr>
<tr class="separator:aaf6bdc0cd48750d587607d481299a354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713e1c0637374d91c371c227506df0c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a713e1c0637374d91c371c227506df0c7">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a713e1c0637374d91c371c227506df0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list.  <a href="#a713e1c0637374d91c371c227506df0c7">More...</a><br /></td></tr>
<tr class="separator:a713e1c0637374d91c371c227506df0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134b66ce4168b099d24e5b2ea96b5d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#ae134b66ce4168b099d24e5b2ea96b5d1">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ae134b66ce4168b099d24e5b2ea96b5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#ae134b66ce4168b099d24e5b2ea96b5d1">More...</a><br /></td></tr>
<tr class="separator:ae134b66ce4168b099d24e5b2ea96b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0120820fcf6300612c41499374dbb4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a7c0120820fcf6300612c41499374dbb4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a7c0120820fcf6300612c41499374dbb4">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a7c0120820fcf6300612c41499374dbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>item</code> exists in the set.  <a href="#a7c0120820fcf6300612c41499374dbb4">More...</a><br /></td></tr>
<tr class="separator:a7c0120820fcf6300612c41499374dbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed54ee607a957a17a5afd47b8c4929e"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:afed54ee607a957a17a5afd47b8c4929e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#afed54ee607a957a17a5afd47b8c4929e">find</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:afed54ee607a957a17a5afd47b8c4929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#afed54ee607a957a17a5afd47b8c4929e">More...</a><br /></td></tr>
<tr class="separator:afed54ee607a957a17a5afd47b8c4929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded84eb71c2d87512d5fba1f45094ca3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aded84eb71c2d87512d5fba1f45094ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#aded84eb71c2d87512d5fba1f45094ca3">find_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aded84eb71c2d87512d5fba1f45094ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="#aded84eb71c2d87512d5fba1f45094ca3">More...</a><br /></td></tr>
<tr class="separator:aded84eb71c2d87512d5fba1f45094ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18ce45b57197e577547359f73aa87fe"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ac18ce45b57197e577547359f73aa87fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#ac18ce45b57197e577547359f73aa87fe">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:ac18ce45b57197e577547359f73aa87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#ac18ce45b57197e577547359f73aa87fe">More...</a><br /></td></tr>
<tr class="separator:ac18ce45b57197e577547359f73aa87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd18e16bfdc79b8cee23c6aabb567cf"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:abcd18e16bfdc79b8cee23c6aabb567cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#abcd18e16bfdc79b8cee23c6aabb567cf">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:abcd18e16bfdc79b8cee23c6aabb567cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="#abcd18e16bfdc79b8cee23c6aabb567cf">More...</a><br /></td></tr>
<tr class="separator:abcd18e16bfdc79b8cee23c6aabb567cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a5999f67d3f36a5d7cfc085239ec25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a74a5999f67d3f36a5d7cfc085239ec25">empty</a> () const </td></tr>
<tr class="memdesc:a74a5999f67d3f36a5d7cfc085239ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a74a5999f67d3f36a5d7cfc085239ec25">More...</a><br /></td></tr>
<tr class="separator:a74a5999f67d3f36a5d7cfc085239ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854a5d0f31394d299adf04a3df463c47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a854a5d0f31394d299adf04a3df463c47"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a854a5d0f31394d299adf04a3df463c47">size</a> () const </td></tr>
<tr class="memdesc:a854a5d0f31394d299adf04a3df463c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a854a5d0f31394d299adf04a3df463c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b47861f2152d617dfd8bc7bfb315b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a679b47861f2152d617dfd8bc7bfb315b"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a8b2c74efd0b5c534a68b68e89d293dfe">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a679b47861f2152d617dfd8bc7bfb315b">statistics</a> () const </td></tr>
<tr class="memdesc:a679b47861f2152d617dfd8bc7bfb315b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a679b47861f2152d617dfd8bc7bfb315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa78cc84b6af380b1d8456f1bffae1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a1aa78cc84b6af380b1d8456f1bffae1b">begin</a> ()</td></tr>
<tr class="memdesc:a1aa78cc84b6af380b1d8456f1bffae1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a split-list.  <a href="#a1aa78cc84b6af380b1d8456f1bffae1b">More...</a><br /></td></tr>
<tr class="separator:a1aa78cc84b6af380b1d8456f1bffae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc6c6297bd3121e96089b1f6bcff1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#abfc6c6297bd3121e96089b1f6bcff1b3">end</a> ()</td></tr>
<tr class="memdesc:abfc6c6297bd3121e96089b1f6bcff1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a split-list.  <a href="#abfc6c6297bd3121e96089b1f6bcff1b3">More...</a><br /></td></tr>
<tr class="separator:abfc6c6297bd3121e96089b1f6bcff1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1bed17a27a73484d1f08234605c91ae3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bed17a27a73484d1f08234605c91ae3"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a1bed17a27a73484d1f08234605c91ae3">begin</a> () const </td></tr>
<tr class="memdesc:a1bed17a27a73484d1f08234605c91ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:a1bed17a27a73484d1f08234605c91ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3cb36853670580862b899a32cdeff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3cb36853670580862b899a32cdeff5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const </td></tr>
<tr class="separator:a3c3cb36853670580862b899a32cdeff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abde00f1ef138a5e1ae56781214e6142c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abde00f1ef138a5e1ae56781214e6142c"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#abde00f1ef138a5e1ae56781214e6142c">end</a> () const </td></tr>
<tr class="memdesc:abde00f1ef138a5e1ae56781214e6142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:abde00f1ef138a5e1ae56781214e6142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8659f2613c20b52a34453ba5b5f2e56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8659f2613c20b52a34453ba5b5f2e56"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const </td></tr>
<tr class="separator:ad8659f2613c20b52a34453ba5b5f2e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a547011447eedd4f8e21a36ccf3a8bcdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547011447eedd4f8e21a36ccf3a8bcdb"></a>
typedef ordered_list::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a547011447eedd4f8e21a36ccf3a8bcdb">list_node_type</a></td></tr>
<tr class="memdesc:a547011447eedd4f8e21a36ccf3a8bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type as declared in ordered list. <br /></td></tr>
<tr class="separator:a547011447eedd4f8e21a36ccf3a8bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95827659a6a5f92550fc6549096710d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95827659a6a5f92550fc6549096710d3"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node.html">split_list::node</a><br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a547011447eedd4f8e21a36ccf3a8bcdb">list_node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a95827659a6a5f92550fc6549096710d3">node_type</a></td></tr>
<tr class="memdesc:a95827659a6a5f92550fc6549096710d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">split-list node type <br /></td></tr>
<tr class="separator:a95827659a6a5f92550fc6549096710d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69565922cab328a92e692c0ab34af9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69565922cab328a92e692c0ab34af9e"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a95827659a6a5f92550fc6549096710d3">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#af69565922cab328a92e692c0ab34af9e">dummy_node_type</a></td></tr>
<tr class="memdesc:af69565922cab328a92e692c0ab34af9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy node type <br /></td></tr>
<tr class="separator:af69565922cab328a92e692c0ab34af9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4080efde26d74a123a3cd465abe3f549"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak" />
<a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node__traits.html">split_list::node_traits</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
ordered_list::node_traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a4080efde26d74a123a3cd465abe3f549">node_traits</a></td></tr>
<tr class="memdesc:a4080efde26d74a123a3cd465abe3f549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-list node traits.  <a href="#a4080efde26d74a123a3cd465abe3f549">More...</a><br /></td></tr>
<tr class="separator:a4080efde26d74a123a3cd465abe3f549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a97315d7a6070072eebdbe4c7fbed86ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97315d7a6070072eebdbe4c7fbed86ea"></a>
ordered_list_wrapper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a97315d7a6070072eebdbe4c7fbed86ea">m_List</a></td></tr>
<tr class="memdesc:a97315d7a6070072eebdbe4c7fbed86ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list containing split-list items. <br /></td></tr>
<tr class="separator:a97315d7a6070072eebdbe4c7fbed86ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcca059d15bb63bf905c8951bf0c03b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcca059d15bb63bf905c8951bf0c03b4"></a>
bucket_table&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#adcca059d15bb63bf905c8951bf0c03b4">m_Buckets</a></td></tr>
<tr class="memdesc:adcca059d15bb63bf905c8951bf0c03b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket table <br /></td></tr>
<tr class="separator:adcca059d15bb63bf905c8951bf0c03b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80352402bc71cd0ab9370bbb092f7ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80352402bc71cd0ab9370bbb092f7ef1"></a>
atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a80352402bc71cd0ab9370bbb092f7ef1">m_nBucketCountLog2</a></td></tr>
<tr class="memdesc:a80352402bc71cd0ab9370bbb092f7ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">log2( current bucket count ) <br /></td></tr>
<tr class="separator:a80352402bc71cd0ab9370bbb092f7ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e46ac0ec8d3452df6c3265dbc2c3db8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e46ac0ec8d3452df6c3265dbc2c3db8"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a35602b967de54f9536daa48223abcd3f">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a4e46ac0ec8d3452df6c3265dbc2c3db8">m_ItemCounter</a></td></tr>
<tr class="memdesc:a4e46ac0ec8d3452df6c3265dbc2c3db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a4e46ac0ec8d3452df6c3265dbc2c3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f22f6b9fb6730cbfd5b39b478050b98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f22f6b9fb6730cbfd5b39b478050b98"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a40c36012baece0fe49f32c9749531298">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a4f22f6b9fb6730cbfd5b39b478050b98">m_HashFunctor</a></td></tr>
<tr class="memdesc:a4f22f6b9fb6730cbfd5b39b478050b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a4f22f6b9fb6730cbfd5b39b478050b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ac6802a16b445b788a0ddd38105aaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ac6802a16b445b788a0ddd38105aaa"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a8b2c74efd0b5c534a68b68e89d293dfe">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a60ac6802a16b445b788a0ddd38105aaa">m_Stat</a></td></tr>
<tr class="memdesc:a60ac6802a16b445b788a0ddd38105aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a60ac6802a16b445b788a0ddd38105aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class OrderedList, class Traits = split_list::traits&gt;<br />
class cds::intrusive::SplitListSet&lt; cds::gc::nogc, OrderedList, Traits &gt;</h3>

<p>Split-ordered list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>) </p>
<p><a class="anchor" id="cds_intrusive_SplitListSet_nogc"></a> This specialization is intended for so-called persistent usage when no item reclamation may be performed. The class does not support deleting of list item.</p>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#cds_intrusive_SplitListSet_hp">SplitListSet</a> for description of template parameters. The template parameter <code>OrderedList</code> should be any <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>-derived ordered list, for example, <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_nogc">persistent MichaelList</a>, <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_nogc">persistent LazyList</a> </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a6c0bc5eb6da6e6687e1c07aa20015322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;true&gt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a6c0bc5eb6da6e6687e1c07aa20015322">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const forward iterator. </p>
<p>For iterator's features and requirements see <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a> </p>

</div>
</div>
<a class="anchor" id="acc2a57152625dffb29657e9883f9de3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;false&gt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator for a split-list has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>it depends on iterator of underlying <code>OrderedList</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="a4080efde26d74a123a3cd465abe3f549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node__traits.html">split_list::node_traits</a>&lt;typename ordered_list::node_traits&gt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a4080efde26d74a123a3cd465abe3f549">node_traits</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split-list node traits. </p>
<p>This traits is intended for converting between underlying ordered list node type <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a547011447eedd4f8e21a36ccf3a8bcdb">list_node_type</a> and split-list node type <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a95827659a6a5f92550fc6549096710d3">node_type</a> </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaf6bdc0cd48750d587607d481299a354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize split-ordered list of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table. ">split_list::expandable_bucket_table</a>, split_list::static_ducket_table which selects by <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1dynamic__bucket__table.html" title="[value-option] Split-list dynamic bucket table option ">split_list::dynamic_bucket_table</a> option. </p>

</div>
</div>
<a class="anchor" id="a713e1c0637374d91c371c227506df0c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize split-ordered list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimate average of item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 10, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1aa78cc84b6af380b1d8456f1bffae1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a split-list. </p>
<p>For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a1aa78cc84b6af380b1d8456f1bffae1b">begin</a>() == <a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#abfc6c6297bd3121e96089b1f6bcff1b3">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a74a5999f67d3f36a5d7cfc085239ec25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. Thus, the correct item counting feature is an important part of split-list implementation. </p>

</div>
</div>
<a class="anchor" id="abfc6c6297bd3121e96089b1f6bcff1b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#acc2a57152625dffb29657e9883f9de3c">iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a split-list. </p>
<p>Do not use the value returned by <code>end</code> function to access any item.</p>
<p>The returned value can be used only to control reaching the end of the split-list. For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a1aa78cc84b6af380b1d8456f1bffae1b">begin</a>() == <a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#abfc6c6297bd3121e96089b1f6bcff1b3">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7c0120820fcf6300612c41499374dbb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>item</code> exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> not found in the set, then <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with item found. The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ensure_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code> function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refers to the same thing.</li>
</ul>
<p>The functor can change non-key fields of the <code>item</code>.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with given key already is in the set.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_nogc">MichaelList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_nogc">LazyList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<a class="anchor" id="afed54ee607a957a17a5afd47b8c4929e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_SplitListSet_nogc_find_val"></a>The function searches the item with key equal to <code>key</code> and returns pointer to item found or , and <code>nullptr</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a class="anchor" id="ac18ce45b57197e577547359f73aa87fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_SplitListSet_nogc_find_func"></a>The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a>&amp; item, Q&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>. The functor does not serialize simultaneous access to the set <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aded84eb71c2d87512d5fba1f45094ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> with <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#cds_intrusive_SplitListSet_nogc_find_val">find(Q const&amp;)</a> but <code>cmp</code> is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>cmp</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="abcd18e16bfdc79b8cee23c6aabb567cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> with <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#cds_intrusive_SplitListSet_nogc_find_func">find(Q&amp;, Func)</a> but <code>cmp</code> is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>cmp</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ae134b66ce4168b099d24e5b2ea96b5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OrderedList , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#a5b5a7d35b2bde69ae53efe9d60eae2ad">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with key equal to <code>val</code>.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/split_list_nogc.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:26 by Doxygen 1.8.8</i>
</div>
</body>
</html>
