<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cds: cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">EllenBinTree< cds::urcu::gc< RCU >, Key, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo;  &#124; <a class="el" href="group__cds__intrusive__tree.html">Tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Ellen's et al binary search tree (RCU specialization)  
 <a href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/ellen_bintree_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.png" usemap="#cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" name="cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html" title="Map based on Ellen&#39;s et al binary search tree (RCU specialization) " alt="cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;" shape="rect" coords="0,56,426,80"/>
<area href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html" title="Set based on Ellen&#39;s et al binary search tree (RCU specialization) " alt="cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;" shape="rect" coords="436,56,862,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c077a01c42f58242a9a8534e503ca0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c077a01c42f58242a9a8534e503ca0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1c077a01c42f58242a9a8534e503ca0e">gc</a></td></tr>
<tr class="memdesc:a1c077a01c42f58242a9a8534e503ca0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br /></td></tr>
<tr class="separator:a1c077a01c42f58242a9a8534e503ca0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6b62e5002f389473533d0d8e185da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c6b62e5002f389473533d0d8e185da"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af5c6b62e5002f389473533d0d8e185da">key_type</a></td></tr>
<tr class="memdesc:af5c6b62e5002f389473533d0d8e185da"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br /></td></tr>
<tr class="separator:af5c6b62e5002f389473533d0d8e185da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add56a738dd647d7d4afee42ba853cd49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add56a738dd647d7d4afee42ba853cd49"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a></td></tr>
<tr class="memdesc:add56a738dd647d7d4afee42ba853cd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br /></td></tr>
<tr class="separator:add56a738dd647d7d4afee42ba853cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b44f712412f2e620a0f9259604bd627"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b44f712412f2e620a0f9259604bd627"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0b44f712412f2e620a0f9259604bd627">traits</a></td></tr>
<tr class="memdesc:a0b44f712412f2e620a0f9259604bd627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a0b44f712412f2e620a0f9259604bd627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac013c3b0204eeb76a5c714c31dd8cb5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac013c3b0204eeb76a5c714c31dd8cb5c"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a></td></tr>
<tr class="memdesc:ac013c3b0204eeb76a5c714c31dd8cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:ac013c3b0204eeb76a5c714c31dd8cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a32ff430f6656f931a19abc62559f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2a32ff430f6656f931a19abc62559f0"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a></td></tr>
<tr class="memdesc:ac2a32ff430f6656f931a19abc62559f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:ac2a32ff430f6656f931a19abc62559f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f14b96ac47e63feab582d27c857fe2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f14b96ac47e63feab582d27c857fe2c"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5f14b96ac47e63feab582d27c857fe2c">disposer</a></td></tr>
<tr class="memdesc:a5f14b96ac47e63feab582d27c857fe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">leaf node disposer <br /></td></tr>
<tr class="separator:a5f14b96ac47e63feab582d27c857fe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ca113e8a2f89bf815bfa104053166"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b7ca113e8a2f89bf815bfa104053166"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8b7ca113e8a2f89bf815bfa104053166">back_off</a></td></tr>
<tr class="memdesc:a8b7ca113e8a2f89bf815bfa104053166"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br /></td></tr>
<tr class="separator:a8b7ca113e8a2f89bf815bfa104053166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb733ae1e60a5beb86fd902c0a38071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcb733ae1e60a5beb86fd902c0a38071"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a> = <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1c077a01c42f58242a9a8534e503ca0e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5f14b96ac47e63feab582d27c857fe2c">disposer</a>, void &gt;</td></tr>
<tr class="memdesc:afcb733ae1e60a5beb86fd902c0a38071"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to extracted node <br /></td></tr>
<tr class="separator:afcb733ae1e60a5beb86fd902c0a38071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe0005ae2be7aba4142ad27517220e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbe0005ae2be7aba4142ad27517220e"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#adcbe0005ae2be7aba4142ad27517220e">key_comparator</a></td></tr>
<tr class="memdesc:adcbe0005ae2be7aba4142ad27517220e"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <code>Traits::compare</code> and <code>Traits::less</code> <br /></td></tr>
<tr class="separator:adcbe0005ae2be7aba4142ad27517220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731dd06317b60f47d72a6589e9aad44b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731dd06317b60f47d72a6589e9aad44b"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak" />
&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a> &gt;<br class="typebreak" />
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a731dd06317b60f47d72a6589e9aad44b">node_traits</a></td></tr>
<tr class="memdesc:a731dd06317b60f47d72a6589e9aad44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits. <br /></td></tr>
<tr class="separator:a731dd06317b60f47d72a6589e9aad44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418a8a2566ddddfe7ea67b6b1dd77e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a418a8a2566ddddfe7ea67b6b1dd77e27"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a></td></tr>
<tr class="memdesc:a418a8a2566ddddfe7ea67b6b1dd77e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a418a8a2566ddddfe7ea67b6b1dd77e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77e3d2c0cea41669a09af420ca23ca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa77e3d2c0cea41669a09af420ca23ca6"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa77e3d2c0cea41669a09af420ca23ca6">memory_model</a></td></tr>
<tr class="memdesc:aa77e3d2c0cea41669a09af420ca23ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:aa77e3d2c0cea41669a09af420ca23ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8958b829d39bb62ccc3bc2a19fce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b8958b829d39bb62ccc3bc2a19fce5"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a77b8958b829d39bb62ccc3bc2a19fce5">stat</a></td></tr>
<tr class="memdesc:a77b8958b829d39bb62ccc3bc2a19fce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:a77b8958b829d39bb62ccc3bc2a19fce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4313052cfee71c3035223835a46e41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4313052cfee71c3035223835a46e41"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abf4313052cfee71c3035223835a46e41">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:abf4313052cfee71c3035223835a46e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:abf4313052cfee71c3035223835a46e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730b3ed3122dda0fc19482a2cc3c7c64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a730b3ed3122dda0fc19482a2cc3c7c64"></a>
typedef traits::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a730b3ed3122dda0fc19482a2cc3c7c64">key_extractor</a></td></tr>
<tr class="memdesc:a730b3ed3122dda0fc19482a2cc3c7c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br /></td></tr>
<tr class="separator:a730b3ed3122dda0fc19482a2cc3c7c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb07dbca4932628ac1acd3047b411e22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb07dbca4932628ac1acd3047b411e22"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acb07dbca4932628ac1acd3047b411e22">node_allocator</a></td></tr>
<tr class="memdesc:acb07dbca4932628ac1acd3047b411e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br /></td></tr>
<tr class="separator:acb07dbca4932628ac1acd3047b411e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f7f069984e5dcf6d185e49d3fae02c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12f7f069984e5dcf6d185e49d3fae02c"></a>
typedef <br class="typebreak" />
traits::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a12f7f069984e5dcf6d185e49d3fae02c">update_desc_allocator</a></td></tr>
<tr class="memdesc:a12f7f069984e5dcf6d185e49d3fae02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br /></td></tr>
<tr class="separator:a12f7f069984e5dcf6d185e49d3fae02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e7acb2b4697f619cb598829323adbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e7acb2b4697f619cb598829323adbc"></a>
typedef gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a45e7acb2b4697f619cb598829323adbc">rcu_lock</a></td></tr>
<tr class="memdesc:a45e7acb2b4697f619cb598829323adbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:a45e7acb2b4697f619cb598829323adbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad038f808e1c52cba16bd09c044ae9a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad038f808e1c52cba16bd09c044ae9a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aad038f808e1c52cba16bd09c044ae9a0">EllenBinTree</a> ()</td></tr>
<tr class="memdesc:aad038f808e1c52cba16bd09c044ae9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aad038f808e1c52cba16bd09c044ae9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce6aaf0ca14b0731c0db3a61e7d4012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce6aaf0ca14b0731c0db3a61e7d4012"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6ce6aaf0ca14b0731c0db3a61e7d4012">~EllenBinTree</a> ()</td></tr>
<tr class="memdesc:a6ce6aaf0ca14b0731c0db3a61e7d4012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree. <br /></td></tr>
<tr class="separator:a6ce6aaf0ca14b0731c0db3a61e7d4012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02172bcb0d7173db7c6eae9967a1fa28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a02172bcb0d7173db7c6eae9967a1fa28">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a02172bcb0d7173db7c6eae9967a1fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a02172bcb0d7173db7c6eae9967a1fa28">More...</a><br /></td></tr>
<tr class="separator:a02172bcb0d7173db7c6eae9967a1fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a720938b154f0d19179a7a92610ed459b">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a720938b154f0d19179a7a92610ed459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a720938b154f0d19179a7a92610ed459b">More...</a><br /></td></tr>
<tr class="separator:a720938b154f0d19179a7a92610ed459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a96086eb88ec0537a00c69f2c3173489e">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a96086eb88ec0537a00c69f2c3173489e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the tree.  <a href="#a96086eb88ec0537a00c69f2c3173489e">More...</a><br /></td></tr>
<tr class="separator:a96086eb88ec0537a00c69f2c3173489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e6bffddd1f5edf3e35729d7d031a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a973e6bffddd1f5edf3e35729d7d031a4">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a973e6bffddd1f5edf3e35729d7d031a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the tree.  <a href="#a973e6bffddd1f5edf3e35729d7d031a4">More...</a><br /></td></tr>
<tr class="separator:a973e6bffddd1f5edf3e35729d7d031a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be3aa2a573ac843f86a45760f9c933"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ab1be3aa2a573ac843f86a45760f9c933"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab1be3aa2a573ac843f86a45760f9c933">erase</a> (const Q &amp;key)</td></tr>
<tr class="memdesc:ab1be3aa2a573ac843f86a45760f9c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#ab1be3aa2a573ac843f86a45760f9c933">More...</a><br /></td></tr>
<tr class="separator:ab1be3aa2a573ac843f86a45760f9c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c01a8af4c00ca1b17c5e8452b0b87f8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2c01a8af4c00ca1b17c5e8452b0b87f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2c01a8af4c00ca1b17c5e8452b0b87f8">erase_with</a> (const Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a2c01a8af4c00ca1b17c5e8452b0b87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#a2c01a8af4c00ca1b17c5e8452b0b87f8">More...</a><br /></td></tr>
<tr class="separator:a2c01a8af4c00ca1b17c5e8452b0b87f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba01e363a5df1fdc502517cc4e0d660"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a3ba01e363a5df1fdc502517cc4e0d660"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3ba01e363a5df1fdc502517cc4e0d660">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a3ba01e363a5df1fdc502517cc4e0d660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#a3ba01e363a5df1fdc502517cc4e0d660">More...</a><br /></td></tr>
<tr class="separator:a3ba01e363a5df1fdc502517cc4e0d660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4902c886150f9d7565943a7cad59af1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ab4902c886150f9d7565943a7cad59af1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab4902c886150f9d7565943a7cad59af1">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ab4902c886150f9d7565943a7cad59af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#ab4902c886150f9d7565943a7cad59af1">More...</a><br /></td></tr>
<tr class="separator:ab4902c886150f9d7565943a7cad59af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524390f3d77ca7f58b13dcd3f751c7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a524390f3d77ca7f58b13dcd3f751c7c8">extract_min</a> ()</td></tr>
<tr class="memdesc:a524390f3d77ca7f58b13dcd3f751c7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the tree.  <a href="#a524390f3d77ca7f58b13dcd3f751c7c8">More...</a><br /></td></tr>
<tr class="separator:a524390f3d77ca7f58b13dcd3f751c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9609cdff48c2b2b5c967f70dab56a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac9609cdff48c2b2b5c967f70dab56a79">extract_max</a> ()</td></tr>
<tr class="memdesc:ac9609cdff48c2b2b5c967f70dab56a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the tree.  <a href="#ac9609cdff48c2b2b5c967f70dab56a79">More...</a><br /></td></tr>
<tr class="separator:ac9609cdff48c2b2b5c967f70dab56a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db71821513ed5c506a309d86a0fac4d"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7db71821513ed5c506a309d86a0fac4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a7db71821513ed5c506a309d86a0fac4d">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a7db71821513ed5c506a309d86a0fac4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the tree.  <a href="#a7db71821513ed5c506a309d86a0fac4d">More...</a><br /></td></tr>
<tr class="separator:a7db71821513ed5c506a309d86a0fac4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582d238f8eb62f6a58d3faa75f85a972"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a582d238f8eb62f6a58d3faa75f85a972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a582d238f8eb62f6a58d3faa75f85a972">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a582d238f8eb62f6a58d3faa75f85a972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> for searching.  <a href="#a582d238f8eb62f6a58d3faa75f85a972">More...</a><br /></td></tr>
<tr class="separator:a582d238f8eb62f6a58d3faa75f85a972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5db76730a42120d76f5a6c02fdb5ba4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:af5db76730a42120d76f5a6c02fdb5ba4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af5db76730a42120d76f5a6c02fdb5ba4">find</a> (Q const &amp;key) const </td></tr>
<tr class="memdesc:af5db76730a42120d76f5a6c02fdb5ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#af5db76730a42120d76f5a6c02fdb5ba4">More...</a><br /></td></tr>
<tr class="separator:af5db76730a42120d76f5a6c02fdb5ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4476332105599e88ea56843da3784109"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a4476332105599e88ea56843da3784109"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4476332105599e88ea56843da3784109">find_with</a> (Q const &amp;key, Less pred) const </td></tr>
<tr class="memdesc:a4476332105599e88ea56843da3784109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with comparing functor <code>pred</code>.  <a href="#a4476332105599e88ea56843da3784109">More...</a><br /></td></tr>
<tr class="separator:a4476332105599e88ea56843da3784109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcb59b2ab84556e27e08720ee798535"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a1dcb59b2ab84556e27e08720ee798535"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1dcb59b2ab84556e27e08720ee798535">find</a> (Q &amp;key, Func f) const </td></tr>
<tr class="memdesc:a1dcb59b2ab84556e27e08720ee798535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a1dcb59b2ab84556e27e08720ee798535">More...</a><br /></td></tr>
<tr class="separator:a1dcb59b2ab84556e27e08720ee798535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab4e706328bc3be2c88dd2cd2d2ff33"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:abab4e706328bc3be2c88dd2cd2d2ff33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abab4e706328bc3be2c88dd2cd2d2ff33">find_with</a> (Q &amp;key, Less pred, Func f) const </td></tr>
<tr class="memdesc:abab4e706328bc3be2c88dd2cd2d2ff33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with comparing functor <code>pred</code>.  <a href="#abab4e706328bc3be2c88dd2cd2d2ff33">More...</a><br /></td></tr>
<tr class="separator:abab4e706328bc3be2c88dd2cd2d2ff33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7f0bbcf3f635ef59ed020ae02f4390"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5b7f0bbcf3f635ef59ed020ae02f4390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5b7f0bbcf3f635ef59ed020ae02f4390">get</a> (Q const &amp;key) const </td></tr>
<tr class="memdesc:a5b7f0bbcf3f635ef59ed020ae02f4390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a5b7f0bbcf3f635ef59ed020ae02f4390">More...</a><br /></td></tr>
<tr class="separator:a5b7f0bbcf3f635ef59ed020ae02f4390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d48559fb24c11e321941683b4c7f8d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a43d48559fb24c11e321941683b4c7f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a43d48559fb24c11e321941683b4c7f8d">get_with</a> (Q const &amp;key, Less pred) const </td></tr>
<tr class="memdesc:a43d48559fb24c11e321941683b4c7f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> with <code>pred</code> predicate and return the item found.  <a href="#a43d48559fb24c11e321941683b4c7f8d">More...</a><br /></td></tr>
<tr class="separator:a43d48559fb24c11e321941683b4c7f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229deaa9345b5f9c858f2e05dbf357ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229deaa9345b5f9c858f2e05dbf357ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a229deaa9345b5f9c858f2e05dbf357ce">empty</a> () const </td></tr>
<tr class="memdesc:a229deaa9345b5f9c858f2e05dbf357ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the tree is empty. <br /></td></tr>
<tr class="separator:a229deaa9345b5f9c858f2e05dbf357ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de3ae3ed073bf0e9b7890551d3d113c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9de3ae3ed073bf0e9b7890551d3d113c">clear</a> ()</td></tr>
<tr class="memdesc:a9de3ae3ed073bf0e9b7890551d3d113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (thread safe, not atomic)  <a href="#a9de3ae3ed073bf0e9b7890551d3d113c">More...</a><br /></td></tr>
<tr class="separator:a9de3ae3ed073bf0e9b7890551d3d113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80973361880b66bddef6576598957b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa80973361880b66bddef6576598957b2">unsafe_clear</a> ()</td></tr>
<tr class="memdesc:aa80973361880b66bddef6576598957b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (not thread safe)  <a href="#aa80973361880b66bddef6576598957b2">More...</a><br /></td></tr>
<tr class="separator:aa80973361880b66bddef6576598957b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f1ab0d1f40d330a1e6815c315482d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a864f1ab0d1f40d330a1e6815c315482d">size</a> () const </td></tr>
<tr class="memdesc:a864f1ab0d1f40d330a1e6815c315482d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the tree.  <a href="#a864f1ab0d1f40d330a1e6815c315482d">More...</a><br /></td></tr>
<tr class="separator:a864f1ab0d1f40d330a1e6815c315482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619c8794b92e04f9115b11af571d446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8619c8794b92e04f9115b11af571d446"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a77b8958b829d39bb62ccc3bc2a19fce5">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8619c8794b92e04f9115b11af571d446">statistics</a> () const </td></tr>
<tr class="memdesc:a8619c8794b92e04f9115b11af571d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a8619c8794b92e04f9115b11af571d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa29830fbf8664dcc3611e23d3ec0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1caa29830fbf8664dcc3611e23d3ec0a">check_consistency</a> () const </td></tr>
<tr class="memdesc:a1caa29830fbf8664dcc3611e23d3ec0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a1caa29830fbf8664dcc3611e23d3ec0a">More...</a><br /></td></tr>
<tr class="separator:a1caa29830fbf8664dcc3611e23d3ec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a69c7fbc4ade056525139f3d5a4c9ba63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69c7fbc4ade056525139f3d5a4c9ba63"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a69c7fbc4ade056525139f3d5a4c9ba63">c_bExtractLockExternal</a> = false</td></tr>
<tr class="memdesc:a69c7fbc4ade056525139f3d5a4c9ba63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions do not require external locking. <br /></td></tr>
<tr class="separator:a69c7fbc4ade056525139f3d5a4c9ba63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3e7f05c5f6483acbc00aa7ede418730f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e7f05c5f6483acbc00aa7ede418730f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3e7f05c5f6483acbc00aa7ede418730f">m_ItemCounter</a></td></tr>
<tr class="memdesc:a3e7f05c5f6483acbc00aa7ede418730f"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a3e7f05c5f6483acbc00aa7ede418730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72420a225c0fd08e642748ce756e72c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72420a225c0fd08e642748ce756e72c7"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a77b8958b829d39bb62ccc3bc2a19fce5">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a72420a225c0fd08e642748ce756e72c7">m_Stat</a></td></tr>
<tr class="memdesc:a72420a225c0fd08e642748ce756e72c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:a72420a225c0fd08e642748ce756e72c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename T, class Traits = ellen_bintree::traits&gt;<br />
class cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</h3>

<p>Ellen's et al binary search tree (RCU specialization) </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu"></a> Source:</p><ul>
<li>[2010] F.Ellen, P.Fatourou, E.Ruppert, F.van Breugel "Non-blocking Binary Search Tree"</li>
</ul>
<p>EllenBinTree is an unbalanced leaf-oriented binary search tree that implements the <em>set</em> abstract data type. Nodes maintains child pointers but not parent pointers. Every internal node has exactly two children, and all data of type <code>T</code> currently in the tree are stored in the leaves. Internal nodes of the tree are used to direct <code>find</code> operation along the path to the correct leaf. The keys (of <code>Key</code> type) stored in internal nodes may or may not be in the set. <code>Key</code> type is a subset of <code>T</code> type. There should be exactly defined a key extracting functor for converting object of type <code>T</code> to object of type <code>Key</code>.</p>
<p>Due to <code>extract_min</code> and <code>extract_max</code> member functions the <code>EllenBinTree</code> can act as a <em>priority queue</em>. In this case you should provide unique compound key, for example, the priority value plus some uniformly distributed random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Recall the tree is <b>unbalanced</b>. The complexity of operations is <code>O(log N)</code> for uniformly distributed random keys, but in worst case the complexity is <code>O(N)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the current implementation we do not use helping technique described in the original paper. In Hazard Pointer schema helping is too complicated and does not give any observable benefits. Instead of helping, when a thread encounters a concurrent operation it just spins waiting for the operation done. Such solution allows greatly simplify the implementation of tree.</dd></dl>
<p><b>Template arguments</b> :</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type, a subset of <code>T</code> </li>
<li><code>T</code> - type to be stored in tree's leaf nodes. The type must be based on <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html" title="Ellen&#39;s binary tree leaf node. ">ellen_bintree::node</a></code> (for <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1base__hook.html" title="Base hook. ">ellen_bintree::base_hook</a></code>) or it must have a member of type <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html" title="Ellen&#39;s binary tree leaf node. ">ellen_bintree::node</a></code> (for <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1member__hook.html" title="Member hook. ">ellen_bintree::member_hook</a></code>).</li>
<li><code>Traits</code> - tree traits, default is <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1traits.html" title="EllenBinTree traits. ">ellen_bintree::traits</a></code> It is possible to declare option-based tree with <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1make__traits.html" title="Metafunction converting option list to EllenBinTree traits. ">ellen_bintree::make_traits</a></code> metafunction instead of <code>Traits</code> template argument.</li>
</ul>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_less"></a><b>Predicate requirements</b></p>
<p><code>Traits::less</code>, <code>Traits::compare</code> and other predicates using with member fuctions should accept at least parameters of type <code>T</code> and <code>Key</code> in any combination. For example, for <code>Foo</code> struct with <code>std::string</code> key field the appropiate <code>less</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html">cds::intrusive::ellen_bintree::node</a>&lt; ... &gt;</div>
<div class="line">{</div>
<div class="line">    std::string m_strKey;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_strKey &lt; v2.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/intrusive/ellen_bintree_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files.</dd></dl>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_usage"></a><b>Usage</b></p>
<p>Suppose we have the following Foo struct with string key type: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">    std::string     m_strKey    ;   <span class="comment">// The key</span></div>
<div class="line">    <span class="comment">//...                           // other non-key data</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>We want to utilize RCU-based <code>cds::intrusive::EllenBinTree</code> set for <code>Foo</code> data. We may use base hook or member hook. Consider base hook variant. First, we need deriving <code>Foo</code> struct from <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html" title="Ellen&#39;s binary tree leaf node. ">cds::intrusive::ellen_bintree::node</a></code>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/ellen_bintree_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// RCU type we use</span></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;  gpb_rcu;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Foo: <span class="keyword">public</span> <a class="code" href="namespacecds_1_1intrusive.html">cds::intrusive</a>:ellen_bintree::node&lt; gpb_rcu &gt;</div>
<div class="line">{</div>
<div class="line">    std::string     m_strKey    ;   <span class="comment">// The key</span></div>
<div class="line">    <span class="comment">//...                           // other non-key data</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Second, we need to implement auxiliary structures and functors:</p><ul>
<li>key extractor functor for extracting the key from <code>Foo</code> object. Such functor is necessary because the tree internal nodes store the keys.</li>
<li><code>less</code> predicate. We want our set should accept <code>std::string</code> and <code>char const *</code> parameters for searching, so our <code>less</code> predicate will not be trivial, see below.</li>
<li>item counting feature: we want our set's <code><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a864f1ab0d1f40d330a1e6815c315482d" title="Returns item count in the tree. ">size()</a></code> member function returns actual item count.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Key extractor functor</span></div>
<div class="line"><span class="keyword">struct </span>my_key_extractor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( std::string&amp; key, Foo <span class="keyword">const</span>&amp; src )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        key = src.m_strKey;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Less predicate</span></div>
<div class="line"><span class="keyword">struct </span>my_less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_strKey &lt; v2.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Tree traits for our set</span></div>
<div class="line"><span class="comment">// It is necessary to specify only those typedefs that differ from</span></div>
<div class="line"><span class="comment">// cds::intrusive::ellen_bintree::traits defaults.</span></div>
<div class="line"><span class="keyword">struct </span>set_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1traits.html">cds::intrusive::ellen_bintree::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1base__hook.html">cds::intrusive::ellen_bintree::base_hook&lt; cds::opt::gc&lt;gpb_rcu&gt;</a> &gt; &gt; <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a>;</div>
<div class="line">    <span class="keyword">typedef</span> my_key_extractor    <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a730b3ed3122dda0fc19482a2cc3c7c64">key_extractor</a>;</div>
<div class="line">    <span class="keyword">typedef</span> my_less             less;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1atomicity_1_1item__counter.html">cds::atomicity::item_counter</a> <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now we declare <code>EllenBinTree</code> set and use it: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; gpb_rcu, std::string, Foo, set_traits &gt;</a>   set_type;</div>
<div class="line"></div>
<div class="line">set_type    theSet;</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Instead of declaring <code>set_traits</code> type traits we can use option-based syntax with <code><a class="el" href="structcds_1_1intrusive_1_1ellen__bintree_1_1make__traits.html" title="Metafunction converting option list to EllenBinTree traits. ">ellen_bintree::make_traits</a></code> metafunction, for example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; gpb_rcu, std::string, Foo,</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1make__traits.html">cds::intrusive::ellen_bintree::make_traits</a>&lt;</div>
<div class="line">        cds::opt::hook&lt; cds::intrusive::ellen_bintree::base_hook&lt; cds::opt::gc&lt;gpb_rcu&gt; &gt; &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1key__extractor.html">cds::intrusive::ellen_bintree::key_extractor&lt; my_key_extractor &gt;</a></div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; my_less &gt;</a></div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1item__counter.html">cds::opt::item_counter&lt; cds::atomicity::item_counter &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;   set_type2;</div>
</div><!-- fragment --><p>Functionally, <code>set_type</code> and <code>set_type2</code> are equivalent.</p>
<p><b>Member-hooked tree</b></p>
<p>Sometimes, we cannot use base hook, for example, when the <code>Foo</code> structure is external. In such case we can use member hook feature. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/ellen_bintree_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Struct Foo is external and its declaration cannot be modified.</span></div>
<div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">    std::string     m_strKey    ;   <span class="comment">// The key</span></div>
<div class="line">    <span class="comment">//...                           // other non-key data</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// RCU type we use</span></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;  gpb_rcu;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Foo wrapper</span></div>
<div class="line"><span class="keyword">struct </span>MyFoo</div>
<div class="line">{</div>
<div class="line">    Foo     m_foo;</div>
<div class="line">    <a class="code" href="namespacecds_1_1intrusive.html">cds::intrusive</a>:ellen_bintree::node&lt; gpb_rcu &gt;   set_hook;   <span class="comment">// member hook</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Key extractor functor</span></div>
<div class="line"><span class="keyword">struct </span>member_key_extractor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( std::string&amp; key, MyFoo <span class="keyword">const</span>&amp; src )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        key = src.m_foo.m_strKey;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Less predicate</span></div>
<div class="line"><span class="keyword">struct </span>member_less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( MyFoo <span class="keyword">const</span>&amp; v1, MyFoo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_foo.m_strKey &lt; v2.m_foo.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( MyFoo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_foo.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, MyFoo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_foo.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( MyFoo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_foo.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, MyFoo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_foo.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Tree traits for our member-based set</span></div>
<div class="line"><span class="keyword">struct </span>member_set_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1traits.html">cds::intrusive::ellen_bintree::traits</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1member__hook.html">cds::intrusive::ellen_bintree::member_hook&lt; offsetof(MyFoo, set_hook), cds::opt::gc&lt;gpb_rcu&gt;</a> &gt; &gt; <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a>;</div>
<div class="line">    <span class="keyword">typedef</span> member_key_extractor    <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a730b3ed3122dda0fc19482a2cc3c7c64">key_extractor</a>;</div>
<div class="line">    <span class="keyword">typedef</span> member_less             less;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1atomicity_1_1item__counter.html">cds::atomicity::item_counter</a> <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Tree containing MyFoo objects</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; gpb_rcu, std::string, MyFoo, member_set_traits &gt;</a>   member_set_type;</div>
<div class="line"></div>
<div class="line">member_set_type    theMemberSet;</div>
</div><!-- fragment --><p><b>Multiple containers</b></p>
<p>Sometimes we need that our <code>Foo</code> struct should be used in several different containers. Suppose, <code>Foo</code> struct has two key fields: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">    std::string m_strKey    ;   <span class="comment">// string key</span></div>
<div class="line">    <span class="keywordtype">int</span>         m_nKey      ;   <span class="comment">// int key</span></div>
<div class="line">    <span class="comment">//...                       // other non-key data fields</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>We want to build two intrusive <code>EllenBinTree</code> sets: one indexed on <code>Foo::m_strKey</code> field, another indexed on <code>Foo::m_nKey</code> field. To decide such case we should use a tag option for tree's hook: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/ellen_bintree_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// RCU type we use</span></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;  gpb_rcu;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare tag structs</span></div>
<div class="line"><span class="keyword">struct </span>int_tag      ;   <span class="comment">// int key tag</span></div>
<div class="line"><span class="keyword">struct </span>string_tag   ;   <span class="comment">// string key tag</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Foo struct is derived from two ellen_bintree::node class</span></div>
<div class="line"><span class="comment">// with different tags</span></div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">    : <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html">cds::intrusive::ellen_bintree::node</a>&lt; gpb_rcu, cds::opt::tag&lt; string_tag &gt; &gt;</div>
<div class="line">    , <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1node.html">cds::intrusive::ellen_bintree::node</a>&lt; gpb_rcu &gt;, <a class="code" href="structcds_1_1opt_1_1tag.html">cds::opt::tag</a>&lt; int_tag &gt;</div>
<div class="line">{</div>
<div class="line">    std::string m_strKey    ;   <span class="comment">// string key</span></div>
<div class="line">    <span class="keywordtype">int</span>         m_nKey      ;   <span class="comment">// int key</span></div>
<div class="line">    <span class="comment">//...                       // other non-key data fields</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// String key extractor functor</span></div>
<div class="line"><span class="keyword">struct </span>string_key_extractor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( std::string&amp; key, Foo <span class="keyword">const</span>&amp; src )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        key = src.m_strKey;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Int key extractor functor</span></div>
<div class="line"><span class="keyword">struct </span>int_key_extractor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( <span class="keywordtype">int</span>&amp; key, Foo <span class="keyword">const</span>&amp; src )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        key = src.m_nKey;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// String less predicate</span></div>
<div class="line"><span class="keyword">struct </span>string_less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_strKey &lt; v2.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Int less predicate</span></div>
<div class="line"><span class="keyword">struct </span>int_less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_nKey &lt; v2.m_nKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">int</span> n )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_nKey &lt; n ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">int</span> n, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> n &lt; v.m_nKey ; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Type traits for string-indexed set</span></div>
<div class="line"><span class="keyword">struct </span>string_set_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1traits.html">cds::intrusive::ellen_bintree::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1base__hook.html">cds::intrusive::ellen_bintree::base_hook&lt; cds::opt::gc&lt;gpb_rcu&gt;</a> &gt;, <a class="code" href="structcds_1_1opt_1_1tag.html">cds::opt::tag&lt; string_tag &gt;</a> &gt; <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a>;</div>
<div class="line">    <span class="keyword">typedef</span> string_key_extractor    <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a730b3ed3122dda0fc19482a2cc3c7c64">key_extractor</a>;</div>
<div class="line">    <span class="keyword">typedef</span> string_less             less;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1atomicity_1_1item__counter.html">cds::atomicity::item_counter</a> <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Type traits for int-indexed set</span></div>
<div class="line"><span class="keyword">struct </span>int_set_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1traits.html">cds::intrusive::ellen_bintree::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1ellen__bintree_1_1base__hook.html">cds::intrusive::ellen_bintree::base_hook&lt; cds::opt::gc&lt;gpb_rcu&gt;</a> &gt;, <a class="code" href="structcds_1_1opt_1_1tag.html">cds::opt::tag&lt; int_tag &gt;</a> &gt; <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac013c3b0204eeb76a5c714c31dd8cb5c">hook</a>;</div>
<div class="line">    <span class="keyword">typedef</span> int_key_extractor    <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a730b3ed3122dda0fc19482a2cc3c7c64">key_extractor</a>;</div>
<div class="line">    <span class="keyword">typedef</span> int_less             less;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1atomicity_1_1item__counter.html">cds::atomicity::item_counter</a> <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a418a8a2566ddddfe7ea67b6b1dd77e27">item_counter</a>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare string-indexed set</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; gpb_rcu, std::string, Foo, string_set_traits &gt;</a>   string_set_type;</div>
<div class="line">string_set_type theStringSet;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare int-indexed set</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; gpb_rcu, int, Foo, int_set_traits &gt;</a>   int_set_type;</div>
<div class="line">int_set_type    theIntSet;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now we can use theStringSet and theIntSet in our program</span></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1caa29830fbf8664dcc3611e23d3ec0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a9de3ae3ed073bf0e9b7890551d3d113c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the tree (thread safe, not atomic) </p>
<p>The function unlink all items from the tree. The function is thread safe but not atomic: in multi-threaded environment with parallel insertions this sequence </p><div class="fragment"><div class="line">set.clear();</div>
<div class="line">assert( set.empty() );</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each leaf the <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5f14b96ac47e63feab582d27c857fe2c">disposer</a> will be called after unlinking.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a96086eb88ec0537a00c69f2c3173489e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>val</code> exists in the tree. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the tree, then <code>val</code> is inserted into the tree. Otherwise, the functor <code>func</code> is called with item found. The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the tree</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code> function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refer to the same thing.</li>
</ul>
<p>The functor can change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already is in the tree.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1be3aa2a573ac843f86a45760f9c933"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the tree. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_erase"></a>The function searches an item with key equal to <code>key</code> in the tree, unlinks it from the tree, and returns <code>true</code>. If the item with key equal to <code>key</code> is not found the function return <code>false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a3ba01e363a5df1fdc502517cc4e0d660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the tree. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_erase_func"></a>The function searches an item with key equal to <code>key</code> in the tree, call <code>f</code> functor with item found, unlinks it from the tree, and returns <code>true</code>. The <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5f14b96ac47e63feab582d27c857fe2c">disposer</a> specified in <code>Traits</code> class template parameter is called by garbage collector <code>GC</code> asynchronously.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> <span class="keyword">const</span>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>If the item with key equal to <code>key</code> is not found the function return <code>false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a2c01a8af4c00ca1b17c5e8452b0b87f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the item from the tree with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_erase">erase(Q const&amp;)</a> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the interface like <code>std::less</code> and should meet <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_less">Predicate requirements</a>. <code>pred</code> must imply the same element order as the comparator used for building the tree. </p>

</div>
</div>
<a class="anchor" id="ab4902c886150f9d7565943a7cad59af1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the item from the tree with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the interface like <code>std::less</code> and should meet <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_less">Predicate requirements</a>. <code>pred</code> must imply the same element order as the comparator used for building the tree. </p>

</div>
</div>
<a class="anchor" id="a7db71821513ed5c506a309d86a0fac4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the tree. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the tree, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to an item found. If the item with the key equal to <code>key</code> is not found the function returns empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="ac9609cdff48c2b2b5c967f70dab56a79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the tree. </p>
<p>The function searches an item with maximal key, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the rightmost item. If the tree is empty the function returns empty <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the tree, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than rightmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="a524390f3d77ca7f58b13dcd3f751c7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the tree. </p>
<p>The function searches an item with minimal key, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the leftmost item. If the tree is empty the function returns empty <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the tree, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="a582d238f8eb62f6a58d3faa75f85a972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afcb733ae1e60a5beb86fd902c0a38071">exempt_ptr</a> <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the set using <code>pred</code> for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_extract">extract(exempt_ptr&amp;, Q const&amp;)</a> but <code>pred</code> is used for key compare. <code>Less</code> has the interface like <code>std::less</code> and should meet <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_less">predicate requirements</a>. <code>pred</code> must imply the same element order as the comparator used for building the tree. </p>

</div>
</div>
<a class="anchor" id="af5db76730a42120d76f5a6c02fdb5ba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_find_val"></a>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a1dcb59b2ab84556e27e08720ee798535"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_find_func"></a>The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>&amp; item, Q&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the tree <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4476332105599e88ea56843da3784109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key compare. <code>Less</code> functor has the interface like <code>std::less</code> and should meet <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_less">Predicate requirements</a>. <code>pred</code> must imply the same element order as the comparator used for building the tree. <code>pred</code> should accept arguments of type <code>Q</code>, <code>key_type</code>, <code>value_type</code> in any combination. </p>

</div>
</div>
<a class="anchor" id="abab4e706328bc3be2c88dd2cd2d2ff33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparison. <code>Less</code> functor has the interface like <code>std::less</code> and should meet <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_less">Predicate requirements</a>. <code>pred</code> must imply the same element order as the comparator used for building the tree. </p>

</div>
</div>
<a class="anchor" id="a5b7f0bbcf3f635ef59ed020ae02f4390"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>* <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_intrusive_EllenBinTree_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns the pointer to item found. If <code>key</code> is not found it returns <code>nullptr</code>.</p>
<p>RCU should be locked before call the function. Returned pointer is valid while RCU is locked. </p>

</div>
</div>
<a class="anchor" id="a43d48559fb24c11e321941683b4c7f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>* <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> with <code>pred</code> predicate and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_intrusive_EllenBinTree_rcu_get">get(Q const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the tree. </p>

</div>
</div>
<a class="anchor" id="a02172bcb0d7173db7c6eae9967a1fa28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the tree if it does not contain an item with key equal to <code>val</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a720938b154f0d19179a7a92610ed459b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>This function is intended for derived non-intrusive containers.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the tree</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this tree's item by concurrent threads. The user-defined functor is called only if the inserting is success.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a864f1ab0d1f40d330a1e6815c315482d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the tree. </p>
<p>Only leaf nodes containing user data are counted.</p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> this function always returns 0.</p>
<p>The function is not suitable for checking the tree emptiness, use <code><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a229deaa9345b5f9c858f2e05dbf357ce" title="Checks if the tree is empty. ">empty()</a></code> member function for that. </p>

</div>
</div>
<a class="anchor" id="a973e6bffddd1f5edf3e35729d7d031a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the item <code>val</code> from the tree. </p>
<p>The function searches the item <code>val</code> in the tree and unlink it from the tree if it is found and is equal to <code>val</code>.</p>
<p>Difference between <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab1be3aa2a573ac843f86a45760f9c933">erase</a> and <code>unlink</code> functions: <code>erase</code> finds <em>a key</em> and deletes the item found. <code>unlink</code> finds an item by key and deletes it only if <code>val</code> is an item of the tree, i.e. the pointer to item found is equal to <code> &amp;val </code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>The <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5f14b96ac47e63feab582d27c857fe2c">disposer</a> specified in <code>Traits</code> class template parameter is called by garbage collector <code>GC</code> asynchronously.</p>
<p>The function returns <code>true</code> if success and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aa80973361880b66bddef6576598957b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletoncds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::unsafe_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the tree (not thread safe) </p>
<p>This function is not thread safe and may be called only when no other thread deals with the tree. The function is used in the tree destructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/ellen_bintree_rcu.h</li>
</ul>
</div><!-- contents -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.0.0</b> 
  Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2014
  <br/>
  <i>Autogenerated Tue Dec 30 2014 08:53:24 by Doxygen 1.8.8</i>
</div>
</body>
</html>
